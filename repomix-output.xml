This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
src/
  alignment.ts
  app.ts
  index.html
  styles.css
.gitignore
CLAUDE.md
package.json
readme.md
SmartAlign.md
tsconfig.json
Update.prd
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(open:*)",
      "Bash(grep:*)",
      "Bash(sed:*)",
      "Bash(npx tsc:*)",
      "Bash(npm install)",
      "Bash(rm:*)",
      "Bash(npm run build:*)",
      "Bash(npm install:*)",
      "Bash(npm run dev:*)",
      "Bash(ls:*)",
      "Bash(pkill:*)",
      "Bash(cat:*)",
      "Bash(npm run serve:*)",
      "Bash(python3:*)"
    ],
    "deny": []
  }
}
</file>

<file path="src/alignment.ts">
// Alignment Guide System for note positioning
// This file will be compiled separately and included in HTML

declare global {
  interface Window {
    AlignmentCalculator: typeof AlignmentCalculator;
    GuideRenderer: typeof GuideRenderer;
  }
}

interface NoteBounds {
  id: string;
  left: number;
  top: number;
  right: number;
  bottom: number;
  width: number;
  height: number;
  centerX: number;
  centerY: number;
}

export interface AlignmentGuide {
  type: 'vertical' | 'horizontal' | 'vertical-center' | 'horizontal-center';
  position: number;
  strength: number; // 0-1, based on proximity
  sourceNotes: string[]; // IDs of notes causing this guide
  color?: string;
}

export interface SnapResult {
  snapped: boolean;
  deltaX: number;
  deltaY: number;
  guides: AlignmentGuide[];
}

export interface AlignmentOptions {
  snapThreshold: number;
  snapEnabled: boolean;
  showDistances: boolean;
  guideColors: {
    edge: string;
    center: string;
    spacing: string;
  };
}

// Spatial indexing for performance
class QuadTree {
  private bounds: { x: number; y: number; width: number; height: number };
  private maxObjects: number = 10;
  private maxLevels: number = 5;
  private level: number;
  private objects: NoteBounds[] = [];
  private nodes: QuadTree[] = [];

  constructor(bounds: { x: number; y: number; width: number; height: number }, level = 0) {
    this.bounds = bounds;
    this.level = level;
  }

  clear(): void {
    this.objects = [];
    this.nodes = [];
  }

  split(): void {
    const subWidth = this.bounds.width / 2;
    const subHeight = this.bounds.height / 2;
    const x = this.bounds.x;
    const y = this.bounds.y;

    this.nodes[0] = new QuadTree({
      x: x + subWidth,
      y: y,
      width: subWidth,
      height: subHeight
    }, this.level + 1);

    this.nodes[1] = new QuadTree({
      x: x,
      y: y,
      width: subWidth,
      height: subHeight
    }, this.level + 1);

    this.nodes[2] = new QuadTree({
      x: x,
      y: y + subHeight,
      width: subWidth,
      height: subHeight
    }, this.level + 1);

    this.nodes[3] = new QuadTree({
      x: x + subWidth,
      y: y + subHeight,
      width: subWidth,
      height: subHeight
    }, this.level + 1);
  }

  getIndex(bounds: NoteBounds): number {
    let index = -1;
    const verticalMidpoint = this.bounds.x + this.bounds.width / 2;
    const horizontalMidpoint = this.bounds.y + this.bounds.height / 2;

    const topQuadrant = bounds.top < horizontalMidpoint && bounds.bottom < horizontalMidpoint;
    const bottomQuadrant = bounds.top > horizontalMidpoint;

    if (bounds.left < verticalMidpoint && bounds.right < verticalMidpoint) {
      if (topQuadrant) index = 1;
      else if (bottomQuadrant) index = 2;
    } else if (bounds.left > verticalMidpoint) {
      if (topQuadrant) index = 0;
      else if (bottomQuadrant) index = 3;
    }

    return index;
  }

  insert(bounds: NoteBounds): void {
    if (this.nodes.length > 0) {
      const index = this.getIndex(bounds);
      if (index !== -1) {
        this.nodes[index].insert(bounds);
        return;
      }
    }

    this.objects.push(bounds);

    if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
      if (this.nodes.length === 0) {
        this.split();
      }

      let i = 0;
      while (i < this.objects.length) {
        const index = this.getIndex(this.objects[i]);
        if (index !== -1) {
          this.nodes[index].insert(this.objects.splice(i, 1)[0]);
        } else {
          i++;
        }
      }
    }
  }

  retrieve(bounds: NoteBounds): NoteBounds[] {
    const returnObjects: NoteBounds[] = [...this.objects];

    if (this.nodes.length > 0) {
      const index = this.getIndex(bounds);
      if (index !== -1) {
        returnObjects.push(...this.nodes[index].retrieve(bounds));
      } else {
        for (const node of this.nodes) {
          returnObjects.push(...node.retrieve(bounds));
        }
      }
    }

    return returnObjects;
  }
}

class AlignmentCalculator {
  private quadTree: QuadTree | null = null;
  private cachedBounds: Map<string, NoteBounds> = new Map();
  private options: AlignmentOptions;

  constructor(options: Partial<AlignmentOptions> = {}) {
    this.options = {
      snapThreshold: 8,
      snapEnabled: true,
      showDistances: false,
      guideColors: {
        edge: 'rgba(59, 130, 246, 0.6)',    // Blue for edges
        center: 'rgba(239, 68, 68, 0.6)',    // Red for centers
        spacing: 'rgba(34, 197, 94, 0.6)'    // Green for spacing
      },
      ...options
    };
  }

  initializeQuadTree(viewportBounds: { x: number; y: number; width: number; height: number }): void {
    this.quadTree = new QuadTree(viewportBounds);
  }

  cacheNoteBounds(notes: HTMLDivElement[]): void {
    this.cachedBounds.clear();
    
    notes.forEach(note => {
      const id = note.id || note.dataset.noteId || Math.random().toString(36);
      const left = parseInt(note.style.left) || 0;
      const top = parseInt(note.style.top) || 0;
      const width = note.offsetWidth;
      const height = note.offsetHeight;
      
      const bounds: NoteBounds = {
        id,
        left,
        top,
        right: left + width,
        bottom: top + height,
        width,
        height,
        centerX: left + width / 2,
        centerY: top + height / 2
      };
      
      this.cachedBounds.set(id, bounds);
      this.quadTree?.insert(bounds);
    });
  }

  calculateAlignments(
    draggedBounds: NoteBounds,
    excludeIds: Set<string> = new Set()
  ): AlignmentGuide[] {
    const guides: AlignmentGuide[] = [];
    const threshold = this.options.snapThreshold;
    
    // Get nearby notes using quadtree if available
    const nearbyNotes = this.quadTree 
      ? this.quadTree.retrieve(draggedBounds)
      : Array.from(this.cachedBounds.values());
    
    // Check each nearby note for alignments
    nearbyNotes.forEach(targetBounds => {
      if (excludeIds.has(targetBounds.id)) return;
      
      // Vertical edge alignments
      const leftDiff = Math.abs(draggedBounds.left - targetBounds.left);
      if (leftDiff < threshold) {
        guides.push({
          type: 'vertical',
          position: targetBounds.left,
          strength: 1 - (leftDiff / threshold),
          sourceNotes: [targetBounds.id],
          color: this.options.guideColors.edge
        });
      }
      
      const rightDiff = Math.abs(draggedBounds.right - targetBounds.right);
      if (rightDiff < threshold) {
        guides.push({
          type: 'vertical',
          position: targetBounds.right,
          strength: 1 - (rightDiff / threshold),
          sourceNotes: [targetBounds.id],
          color: this.options.guideColors.edge
        });
      }
      
      // Vertical center alignment
      const centerXDiff = Math.abs(draggedBounds.centerX - targetBounds.centerX);
      if (centerXDiff < threshold) {
        guides.push({
          type: 'vertical-center',
          position: targetBounds.centerX,
          strength: 1 - (centerXDiff / threshold),
          sourceNotes: [targetBounds.id],
          color: this.options.guideColors.center
        });
      }
      
      // Horizontal edge alignments
      const topDiff = Math.abs(draggedBounds.top - targetBounds.top);
      if (topDiff < threshold) {
        guides.push({
          type: 'horizontal',
          position: targetBounds.top,
          strength: 1 - (topDiff / threshold),
          sourceNotes: [targetBounds.id],
          color: this.options.guideColors.edge
        });
      }
      
      const bottomDiff = Math.abs(draggedBounds.bottom - targetBounds.bottom);
      if (bottomDiff < threshold) {
        guides.push({
          type: 'horizontal',
          position: targetBounds.bottom,
          strength: 1 - (bottomDiff / threshold),
          sourceNotes: [targetBounds.id],
          color: this.options.guideColors.edge
        });
      }
      
      // Horizontal center alignment
      const centerYDiff = Math.abs(draggedBounds.centerY - targetBounds.centerY);
      if (centerYDiff < threshold) {
        guides.push({
          type: 'horizontal-center',
          position: targetBounds.centerY,
          strength: 1 - (centerYDiff / threshold),
          sourceNotes: [targetBounds.id],
          color: this.options.guideColors.center
        });
      }
    });
    
    // Merge guides at the same position
    const mergedGuides = this.mergeGuides(guides);
    
    // Sort by strength (strongest first)
    return mergedGuides.sort((a, b) => b.strength - a.strength);
  }

  private mergeGuides(guides: AlignmentGuide[]): AlignmentGuide[] {
    const merged = new Map<string, AlignmentGuide>();
    
    guides.forEach(guide => {
      const key = `${guide.type}-${guide.position}`;
      const existing = merged.get(key);
      
      if (existing) {
        existing.sourceNotes.push(...guide.sourceNotes);
        existing.strength = Math.max(existing.strength, guide.strength);
      } else {
        merged.set(key, { ...guide });
      }
    });
    
    return Array.from(merged.values());
  }

  calculateSnapPosition(
    draggedBounds: NoteBounds,
    guides: AlignmentGuide[]
  ): SnapResult {
    if (!this.options.snapEnabled || guides.length === 0) {
      return { snapped: false, deltaX: 0, deltaY: 0, guides: [] };
    }
    
    let deltaX = 0;
    let deltaY = 0;
    const activeGuides: AlignmentGuide[] = [];
    
    // Find strongest vertical guide
    const verticalGuides = guides.filter(g => 
      g.type === 'vertical' || g.type === 'vertical-center'
    );
    
    if (verticalGuides.length > 0) {
      const strongestVertical = verticalGuides[0];
      activeGuides.push(strongestVertical);
      
      if (strongestVertical.type === 'vertical') {
        // Snap to edge
        const currentLeft = draggedBounds.left;
        deltaX = strongestVertical.position - currentLeft;
      } else {
        // Snap to center
        const currentCenterX = draggedBounds.centerX;
        deltaX = strongestVertical.position - currentCenterX;
      }
    }
    
    // Find strongest horizontal guide
    const horizontalGuides = guides.filter(g => 
      g.type === 'horizontal' || g.type === 'horizontal-center'
    );
    
    if (horizontalGuides.length > 0) {
      const strongestHorizontal = horizontalGuides[0];
      activeGuides.push(strongestHorizontal);
      
      if (strongestHorizontal.type === 'horizontal') {
        // Snap to edge
        const currentTop = draggedBounds.top;
        deltaY = strongestHorizontal.position - currentTop;
      } else {
        // Snap to center
        const currentCenterY = draggedBounds.centerY;
        deltaY = strongestHorizontal.position - currentCenterY;
      }
    }
    
    return {
      snapped: activeGuides.length > 0,
      deltaX,
      deltaY,
      guides: activeGuides
    };
  }

  clearCache(): void {
    this.cachedBounds.clear();
    this.quadTree?.clear();
  }

  updateOptions(options: Partial<AlignmentOptions>): void {
    this.options = { ...this.options, ...options };
  }
}

class GuideRenderer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private animationFrame: number | null = null;
  private activeGuides: AlignmentGuide[] = [];
  private fadeTimeout: number | null = null;

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Could not get 2D context');
    this.ctx = ctx;
    
    this.resizeCanvas();
    window.addEventListener('resize', () => this.resizeCanvas());
  }

  private resizeCanvas(): void {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  renderGuides(guides: AlignmentGuide[], immediate = false): void {
    this.activeGuides = guides;
    
    if (this.fadeTimeout) {
      clearTimeout(this.fadeTimeout);
      this.fadeTimeout = null;
    }
    
    if (immediate) {
      this.draw();
    } else {
      this.scheduleAnimation();
    }
  }

  private scheduleAnimation(): void {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    
    this.animationFrame = requestAnimationFrame(() => {
      this.draw();
      this.animationFrame = null;
    });
  }

  private draw(): void {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    this.activeGuides.forEach(guide => {
      this.ctx.save();
      
      // Set line style based on guide strength
      this.ctx.strokeStyle = guide.color || 'rgba(59, 130, 246, 0.6)';
      this.ctx.lineWidth = Math.max(1, guide.strength * 2);
      
      // Draw dashed line for center guides
      if (guide.type.includes('center')) {
        this.ctx.setLineDash([5, 5]);
      } else {
        this.ctx.setLineDash([]);
      }
      
      this.ctx.beginPath();
      
      if (guide.type === 'vertical' || guide.type === 'vertical-center') {
        this.ctx.moveTo(guide.position, 0);
        this.ctx.lineTo(guide.position, this.canvas.height);
      } else {
        this.ctx.moveTo(0, guide.position);
        this.ctx.lineTo(this.canvas.width, guide.position);
      }
      
      this.ctx.stroke();
      this.ctx.restore();
    });
  }

  clear(fadeOut = false): void {
    if (fadeOut) {
      // Implement fade out animation
      this.fadeTimeout = window.setTimeout(() => {
        this.activeGuides = [];
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.fadeTimeout = null;
      }, 150);
    } else {
      this.activeGuides = [];
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
  }

  destroy(): void {
    this.clear();
    window.removeEventListener('resize', () => this.resizeCanvas());
  }
}

// Make classes available globally for app.js
window.AlignmentCalculator = AlignmentCalculator;
window.GuideRenderer = GuideRenderer;
</file>

<file path="SmartAlign.md">
# Smart Align - Implementation Documentation

## Overview

Smart Align is a Photoshop/Figma-style alignment guide system for the Anywhere note-taking application. It provides visual guides and snap-to-align functionality when moving notes, helping users position content precisely with professional-grade alignment assistance.

## Architecture

### Core Components

The Smart Align system consists of three main components:

1. **AlignmentCalculator** - Core logic for calculating alignment guides and snap positions
2. **GuideRenderer** - Canvas-based visual rendering of alignment guides
3. **QuadTree** - Spatial indexing for performance optimization

### File Structure

```
src/
├── alignment.ts          # TypeScript source (excluded from compilation)
├── app.ts               # Integration with main application
└── styles.css           # Visual styling for guides and feedback

dist/
└── alignment.js         # Hand-optimized JavaScript (global script)
```

## Code Flow

### 1. Initialization

```typescript
// System initializes when app loads
guidesCanvas = document.getElementById('alignmentGuides');
alignmentCalculator = new AlignmentCalculator({
  snapThreshold: 8,
  snapEnabled: true,
  guideColors: {
    edge: 'rgba(59, 130, 246, 0.6)',    // Blue for edges
    center: 'rgba(239, 68, 68, 0.6)',   // Red for centers
    spacing: 'rgba(34, 197, 94, 0.6)'   // Green for spacing
  }
});
guideRenderer = new GuideRenderer(guidesCanvas);
```

### 2. Drag Detection

When user enters move mode and starts dragging:

```typescript
// Move tool activation
currentTool = 'move' → note selection → drag start

// Individual note drag
isDraggingNote = true
draggedNote = selectedNote

// Group drag (multiple notes)
isDraggingGroup = true
```

### 3. Bounds Calculation

The system calculates alignment based on selection box boundaries (not individual note elements):

```typescript
// Calculate selection box bounds
let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
selectedNotes.forEach(note => {
  const x = parseInt(note.style.left) + dx;
  const y = parseInt(note.style.top) + dy;
  const w = note.offsetWidth;
  const h = note.offsetHeight;
  minX = Math.min(minX, x);
  minY = Math.min(minY, y);
  maxX = Math.max(maxX, x + w);
  maxY = Math.max(maxY, y + h);
});

const draggedBounds = {
  left: minX,
  top: minY,
  right: maxX,
  bottom: maxY,
  width: maxX - minX,
  height: maxY - minY,
  centerX: (minX + maxX) / 2,
  centerY: (minY + maxY) / 2
};
```

### 4. Spatial Indexing

The QuadTree provides efficient collision detection for large numbers of notes:

```typescript
// Initialize spatial index
alignmentCalculator.initializeQuadTree({
  x: 0, y: 0,
  width: window.innerWidth * 2,
  height: window.innerHeight * 2
});

// Cache note positions
alignmentCalculator.cacheNoteBounds(allNotes);

// Efficient retrieval of nearby notes
const nearbyNotes = this.quadTree.retrieve(draggedBounds);
```

### 5. Alignment Calculation

The system calculates various types of alignments:

```typescript
calculateAlignments(draggedBounds, excludeIds) {
  // Edge alignments (left, right, top, bottom)
  const leftDiff = Math.abs(draggedBounds.left - targetBounds.left);
  if (leftDiff < threshold) {
    guides.push({
      type: 'vertical',
      position: targetBounds.left,
      strength: 1 - (leftDiff / threshold),
      color: this.options.guideColors.edge
    });
  }
  
  // Center alignments
  const centerXDiff = Math.abs(draggedBounds.centerX - targetBounds.centerX);
  if (centerXDiff < threshold) {
    guides.push({
      type: 'vertical-center',
      position: targetBounds.centerX,
      strength: 1 - (centerXDiff / threshold),
      color: this.options.guideColors.center
    });
  }
}
```

### 6. Snap Position Calculation

```typescript
calculateSnapPosition(draggedBounds, guides) {
  // Find strongest alignments
  const verticalGuides = guides.filter(g => 
    g.type === 'vertical' || g.type === 'vertical-center'
  );
  const horizontalGuides = guides.filter(g => 
    g.type === 'horizontal' || g.type === 'horizontal-center'
  );
  
  // Calculate snap deltas
  let deltaX = 0, deltaY = 0;
  if (verticalGuides.length > 0) {
    const strongest = verticalGuides[0];
    deltaX = strongest.position - draggedBounds.centerX;
  }
  
  return { snapped: true, deltaX, deltaY, guides };
}
```

### 7. Visual Rendering

The GuideRenderer draws guides on a dedicated canvas layer:

```typescript
drawGuidesInternal() {
  this.activeGuides.forEach(guide => {
    // Enhanced visual styling
    this.ctx.strokeStyle = guide.color;
    this.ctx.lineWidth = Math.max(2, guide.strength * 3);
    this.ctx.lineCap = 'round';
    
    // Shadow for contrast
    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    this.ctx.shadowBlur = 1;
    
    // Dashed lines for center guides
    if (guide.type.includes('center')) {
      this.ctx.setLineDash([8, 4]);
    }
    
    // Draw guide line
    if (guide.type.startsWith('vertical')) {
      this.ctx.moveTo(guide.position, 0);
      this.ctx.lineTo(guide.position, this.canvas.height);
    } else {
      this.ctx.moveTo(0, guide.position);
      this.ctx.lineTo(this.canvas.width, guide.position);
    }
    this.ctx.stroke();
    
    // Strong alignment indicators
    if (guide.strength > 0.8) {
      // Draw small circles at edges
    }
  });
}
```

## Performance Optimizations

### 1. Debouncing
```typescript
const alignmentDebounceDelay = 16; // ~60fps
const shouldCalculateAlignment = (currentTime - lastAlignmentTime) >= alignmentDebounceDelay;
```

### 2. Spatial Indexing
- QuadTree reduces O(n²) to O(log n) for collision detection
- Only checks nearby notes instead of all notes

### 3. Early Exit Optimizations
```typescript
if (this.cachedBounds.size === 0) return guides;
if (nearbyNotes.length === 0) return guides;
```

### 4. Cache Optimization
```typescript
// Skip rebuild if notes haven't changed
if (this.cachedBounds.size === notes.length) {
  let hasChanged = false;
  notes.forEach(note => {
    if (!this.cachedBounds.has(note.id)) hasChanged = true;
  });
  if (!hasChanged) return;
}
```

## Visual Feedback System

### 1. Guide Animations
- **Fade In**: 150ms smooth opacity transition when guides appear
- **Fade Out**: 200ms smooth opacity transition when guides disappear
- **Strength-based Styling**: Line thickness based on alignment strength

### 2. Snap Feedback
```css
#alignmentGuides.snap-active {
  filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.4));
}
```

### 3. Alt Key Override
```css
#alignmentGuides.snap-disabled {
  opacity: 0.3;
  filter: grayscale(100%);
}
```

### 4. Cursor Feedback
```css
#canvas.move-mode.snap-disabled {
  cursor: not-allowed !important;
}
```

## Integration Points

### 1. Move Tool Integration
- Activates only when `currentTool === 'move'`
- Works with both individual and group note selection
- Integrates with existing resize handles system

### 2. Event Handling
```typescript
document.addEventListener('mousemove', e => {
  if (isDraggingNote || isDraggingGroup) {
    // Alignment calculations here
  }
});
```

### 3. Canvas Coordinate System
- Alignment canvas: `position: fixed` overlay
- Note coordinates: `style.left/top` absolute positioning
- Selection boxes: calculated from note bounds

## Configuration

### Default Settings
```typescript
const options = {
  snapThreshold: 8,        // 8px proximity for snapping
  snapEnabled: true,       // Enable snapping by default
  showDistances: false,    // Future: show distance measurements
  guideColors: {
    edge: 'rgba(59, 130, 246, 0.6)',     // Blue
    center: 'rgba(239, 68, 68, 0.6)',    // Red
    spacing: 'rgba(34, 197, 94, 0.6)'    // Green
  }
};
```

### User Controls
- **Snap Toggle Button**: Enable/disable alignment system
- **Alt Key**: Temporarily disable snapping during drag
- **Visual Indicators**: Show snap status in UI

## Debugging

The system includes comprehensive debugging:

```typescript
console.log('Smart Align Debug - System initialized successfully');
console.log('Smart Align Debug - Found', guides.length, 'alignment guides');
console.log('Smart Align Debug - SNAPPED! Delta:', deltaX, deltaY);
console.log('Smart Align Debug - Performance:', (alignEnd - alignStart).toFixed(2), 'ms');
```

## Future Enhancements

1. **Distance Measurements**: Show pixel distances between aligned elements
2. **Grid Snapping**: Align to invisible grid overlay
3. **Smart Layout Suggestions**: AI-powered layout recommendations
4. **Multi-directional Guides**: Diagonal alignment guides
5. **Magnetic Snapping**: Stronger attraction as elements get closer

## Performance Targets

- **60fps**: Maintain smooth animation during drag operations
- **<2ms**: Alignment calculation time for typical scenarios
- **<100 notes**: Optimal performance threshold
- **16ms**: Debounce interval for 60fps target

## Browser Compatibility

- **Canvas API**: All modern browsers
- **Performance API**: All modern browsers
- **RequestAnimationFrame**: All modern browsers
- **CSS Transforms**: All modern browsers

---

*This implementation provides professional-grade alignment capabilities matching industry-standard design tools while maintaining high performance and smooth user experience.*
</file>

<file path=".gitignore">
node_modules/
dist/
*.log
.DS_Store
</file>

<file path="package.json">
{
  "name": "anywhere",
  "version": "1.0.0",
  "description": "A freeform note-taking application with TypeScript",
  "main": "src/app.js",
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch",
    "serve": "python -m http.server 8080",
    "dev-server": "live-server src --port=3000 --wait=500",
    "dev": "concurrently \"npm run watch\" \"live-server --port=3000 --wait=500 --open=src/index.html\""
  },
  "keywords": [
    "notes",
    "typescript",
    "canvas",
    "note-taking"
  ],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "concurrently": "^9.2.0",
    "live-server": "^1.2.2",
    "typescript": "^5.3.0"
  }
}
</file>

<file path="readme.md">
# Anyplace - Freeform Note Taking

A freeform note-taking application that provides an infinite canvas where you can click anywhere to create text notes with rich formatting options.

## Features

- **Infinite Canvas**: Click anywhere to create a note
- **Rich Text Formatting**: Bold, italic, underline, strikethrough, font size/family, alignment
- **Multi-selection**: Select multiple notes for group operations
- **Document Management**: Multiple documents with search, pinning, and organization
- **Undo/Redo Support**: Full undo/redo history for all operations
- **Copy/Paste**: Copy and paste notes within and between documents
- **Theme System**: Light/dark mode toggle
- **Auto-save**: All changes saved automatically to localStorage

## Keyboard Shortcuts

### Selection & Navigation
- **Escape** - Clear current selection
- **Ctrl/Cmd + A** - Select all notes
- **Delete/Backspace** - Delete selected notes
- **Arrow Keys** - Move selected notes (1px increments)
- **Shift + Arrow Keys** - Move selected notes (10px increments)

### Document Management
- **Ctrl/Cmd + N** - Create new document
- **Ctrl/Cmd + S** - Force save current document

### Editing & Formatting
- **Ctrl/Cmd + Z** - Undo last action
- **Ctrl/Cmd + Shift + Z** - Redo last action
- **Ctrl/Cmd + C** - Copy selected notes
- **Ctrl/Cmd + V** - Paste copied notes
- **Ctrl/Cmd + D** - Duplicate selected notes

#### Text Formatting (selected notes or active note)
- **Ctrl/Cmd + B** - Toggle bold
- **Ctrl/Cmd + I** - Toggle italic  
- **Ctrl/Cmd + U** - Toggle underline
- **Ctrl/Cmd + E** - Center align text
- **Ctrl/Cmd + L** - Left align text
- **Ctrl/Cmd + R** - Right align text

#### Font Size (selected notes only)
- **Ctrl/Cmd + Plus/=** - Increase font size
- **Ctrl/Cmd + Minus** - Decrease font size

## Usage

1. **Creating Notes**: Click anywhere on the canvas to create a new note
2. **Selecting Notes**: 
   - Click and drag to select multiple notes with selection box
   - Shift+click to add notes to selection
   - Click on individual notes to select them
3. **Formatting**: Use the toolbar or keyboard shortcuts to format text
4. **Moving Notes**: Drag individual notes or use arrow keys for precise positioning
5. **Documents**: Use the sidebar to manage multiple documents, search, and organize

## Development

This is a pure client-side application built with vanilla HTML, CSS, and JavaScript.

**Development**: Open `src/index.html` directly in a browser or use a local server  
**No Build Process**: No dependencies or build tools required
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "none",
    "lib": ["DOM", "DOM.Iterable", "ES2020"],
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": false,
    "outDir": "./dist",
    "rootDir": "./src",
    "sourceMap": true,
    "removeComments": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": false,
    "exactOptionalPropertyTypes": false
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "src/alignment.ts"
  ]
}
</file>

<file path="Update.prd">
Product Requirements Document (PRD)
Anywhere App - Feature Enhancement
Executive Summary
This PRD outlines three major feature enhancements for the Anywhere note-taking application:

Hand Tool for canvas navigation
Smart alignment guides with snapping
Media embedding support (images and GIFs)
These features will significantly improve the user experience by providing better canvas navigation, precise note positioning, and richer content creation capabilities.

Feature 1: Hand Tool for Canvas Navigation
Overview
Implement a hand tool that allows users to pan and navigate the canvas by clicking and dragging, similar to design tools like Photoshop or Figma.

User Stories
As a user, I want to quickly pan around my canvas to view different areas of my notes
As a user, I want to use the V hotkey to quickly switch to the hand tool
As a user, I want visual feedback when the hand tool is active
Functional Requirements
Tool Activation
Hotkey: Press 'V' to toggle hand tool mode
Visual indicator in toolbar showing hand tool is active
Cursor changes to grabbing hand icon when active
Spacebar temporary activation (hold spacebar for temporary hand tool)
Canvas Panning
Click and drag to pan the canvas view
Smooth scrolling/panning animation
Momentum-based scrolling (optional: canvas continues moving slightly after release)
Works with both mouse and trackpad
Tool States
Default state: Crosshair cursor (current behavior)
Hand tool inactive: Open hand cursor
Hand tool dragging: Closed/grabbing hand cursor
Integration Requirements
Disable note creation when hand tool is active
Disable text selection when panning
Allow quick toggle between hand tool and selection modes
Remember last tool state when switching documents
Technical Considerations
Store canvas offset position (x, y translation)
Update all note positions relative to canvas offset
Ensure performant rendering during pan operations
Handle boundary conditions (limit panning range if needed)
Feature 2: Smart Alignment Guides & Snapping
Overview
Implement intelligent alignment guides that appear when moving notes, helping users align content precisely with visual guides and optional snapping.

User Stories
As a user, I want to see alignment guides when positioning notes
As a user, I want my notes to snap to alignment points for perfect positioning
As a user, I want to align multiple notes easily
Functional Requirements
Alignment Guide Display
Show vertical guides when note edges/centers align with other notes
Show horizontal guides when note edges/centers align with other notes
Display measurements/distances between notes (optional)
Color-coded guides (e.g., red for center alignment, blue for edge alignment)
Snapping Behavior
Snap threshold: 8-10 pixels proximity
Snap to note edges (top, bottom, left, right)
Snap to note centers (vertical and horizontal)
Snap to equal spacing between notes
Toggle snapping on/off (Alt/Option key to temporarily disable)
Guide Types
Edge alignment guides
Center alignment guides
Equal spacing guides
Canvas center guides
Grid snapping (optional future enhancement)
Performance Requirements
Calculate alignments only for visible notes
Debounce alignment calculations during rapid movement
Smooth guide appearance/disappearance animations
Maximum 60fps during drag operations
Technical Considerations
Efficient collision detection algorithm
R-tree or spatial indexing for large numbers of notes
Canvas layer for rendering guides (separate from notes)
Store note bounding boxes for quick calculations
Feature 3: Media Embedding (Images & GIFs)
Overview
Enable users to embed images and GIFs directly into the canvas, treating them as first-class objects alongside text notes.

User Stories
As a user, I want to paste images from my clipboard onto the canvas
As a user, I want to drag and drop image files onto the canvas
As a user, I want to resize and position embedded media
As a user, I want to embed GIFs that play automatically
Functional Requirements
Media Input Methods
Paste from clipboard (Ctrl/Cmd+V)
Drag and drop files from file system
URL input for remote images/GIFs
Upload button in toolbar
Support formats: JPEG, PNG, GIF, WebP, SVG
Media Object Behavior
Positioned absolutely like notes
Resizable with corner/edge handles
Maintain aspect ratio by default (Shift to free transform)
Selectable and movable like notes
Can be part of multi-selection
Delete with Delete/Backspace keys
Media Display Options
Set maximum initial size (e.g., 500px max dimension)
Border/shadow styling options
Opacity adjustment
Click to view full size (lightbox mode)
GIF playback controls (play/pause on hover)
Storage & Performance
Convert images to base64 for localStorage
Implement size limits (e.g., 5MB per image)
Lazy loading for performance
Thumbnail generation for large images
Compress images before storage
Technical Considerations
FileReader API for local file handling
Canvas or Image element rendering
Base64 encoding/decoding for persistence
Image optimization library integration
Consider IndexedDB for larger storage needs
Implementation Plan: 3-Agent Approach
Agent 1: Hand Tool Implementation
Scope: Canvas navigation and hand tool functionality

Tasks:

Create hand tool button in toolbar UI
Implement V hotkey and spacebar activation
Add canvas translation state management
Implement click-and-drag panning logic
Update cursor states and visual feedback
Adjust note rendering for canvas offset
Add momentum scrolling (optional)
Test with existing selection/creation features
Dependencies: None (can work independently)

Estimated Complexity: Medium

Key Files to Modify:

app.ts: Add hand tool state, pan logic, hotkey handling
styles.css: Add hand tool cursor styles
index.html: Add hand tool button to toolbar
Agent 2: Alignment System Implementation
Scope: Smart guides and snapping functionality

Tasks:

Create alignment calculation engine
Implement guide rendering layer
Add snap detection during drag operations
Create guide line visual components
Implement different guide types (edge, center)
Add settings for snap threshold
Optimize performance for many notes
Add hotkey for toggling snapping
Dependencies: Should coordinate with Agent 1 for canvas offset calculations

Estimated Complexity: High

Key Files to Modify:

app.ts: Add alignment logic, guide rendering, snap calculations
styles.css: Add guide line styles
New file: alignment.ts for alignment engine
Agent 3: Media Embedding Implementation
Scope: Image and GIF support

Tasks:

Implement drag-and-drop handling
Add clipboard paste for images
Create media note type/class
Implement resize handles UI
Add base64 conversion and storage
Implement GIF playback controls
Add media toolbar buttons
Create lightbox view component
Handle storage limits and compression
Dependencies: Needs to integrate with selection system from base code

Estimated Complexity: High

Key Files to Modify:

app.ts: Add media handling, new note types
styles.css: Add media element styles
index.html: Add media upload UI elements
New file: media.ts for media-specific logic
Testing Requirements
Hand Tool Testing
Verify V hotkey activation
Test spacebar temporary activation
Ensure smooth panning performance
Test interaction with note selection
Verify cursor state changes
Test on touch devices
Alignment Testing
Test guide appearance at correct positions
Verify snapping at threshold distance
Test with multiple notes
Performance test with 100+ notes
Test disable snapping with modifier key
Verify guide cleanup after movement
Media Testing
Test all input methods (paste, drag, upload)
Verify format support
Test size limits and compression
Verify GIF playback
Test resize with aspect ratio
Test localStorage limits
Verify selection and deletion
Success Metrics
Canvas navigation time reduced by 40%
Note alignment precision improved (< 5px variance)
User engagement with media features (>30% adoption)
Performance maintained (60fps during all operations)
No increase in storage errors
Feature discovery rate >50% within first week
Future Enhancements
Grid snapping system
Rulers and measurements
Video embedding support
Cloud storage for media
Collaborative cursor tracking
Canvas zoom functionality
Smart layout suggestions
Audio note support
</file>

<file path="src/app.ts">
// Type definitions
interface NoteStyles {
  bold: boolean;
  italic: boolean;
  underline: boolean;
  strike: boolean;
  fontSize: string;
  fontFamily: string;
  align: 'left' | 'center' | 'right';
  listType: 'none' | 'bullet' | 'numbered';
}

interface NoteData {
  x: number;
  y: number;
  text: string;
  html: string;
  styles: NoteStyles;
}

interface AppDocument {
  id: string;
  title: string;
  notes: NoteData[];
  pinned: boolean;
  hasCustomTitle?: boolean;
}

interface NoteObject {
  el: HTMLDivElement;
  styles: NoteStyles;
}

interface AppSettings {
  headerIdleTimeout: number;
  headerCanHide: boolean;
}

interface KeyboardShortcut {
  action: string;
  mac: string;
  windows: string;
}

interface ShortcutSection {
  title: string;
  shortcuts: KeyboardShortcut[];
}

interface KeyboardShortcuts {
  [key: string]: ShortcutSection;
}

interface DocumentHistoryState {
  docId: string;
  notes: NoteData[];
}

type ThemeMode = 'light' | 'dark';
type Platform = 'mac' | 'windows';
type ToolMode = 'default' | 'move';
type FontSize = '12px' | '14px' | '16px' | '18px' | '20px' | '24px' | '28px' | '32px' | '48px';
type FontFamily = 
  | "-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif"
  | "Arial,Helvetica,sans-serif"
  | "'Helvetica Neue',Helvetica,sans-serif"
  | "Verdana,Geneva,sans-serif"
  | "'Trebuchet MS',sans-serif"
  | "'Lucida Sans',sans-serif"
  | "Tahoma,Geneva,sans-serif"
  | "'Segoe UI',Tahoma,Geneva,sans-serif"
  | "Georgia,'Times New Roman',serif"
  | "'Times New Roman',Times,serif"
  | "'Book Antiqua',Palatino,serif"
  | "Garamond,serif"
  | "'Courier New',Courier,monospace"
  | "Monaco,'Lucida Console',monospace"
  | "Consolas,'Liberation Mono',monospace"
  | "'Fira Code',monospace"
  | "Impact,'Arial Black',sans-serif"
  | "'Comic Sans MS',cursive"
  | "Papyrus,fantasy"
  | "'Brush Script MT',cursive";

interface DocumentsStorage {
  [id: string]: AppDocument;
}

// Note: We'll use type assertions (note as any).__noteData for the custom property

// State management
let currentNote: NoteObject | null = null;
let currentDocId: string = '';
let documents: DocumentsStorage = {};
let hasTyped: boolean = false;
let selectedNotes: Set<HTMLDivElement> = new Set();
let isSelecting: boolean = false;
let selectBox: HTMLDivElement | null = null;
let startX: number = 0;
let startY: number = 0;
let isDraggingGroup: boolean = false;
let dragHandle: HTMLDivElement | null = null;
let justCompletedSelection: boolean = false;

// Header auto-hide system
let headerIdleTimer: number | null = null;
let headerIdleTimeout: number = 10000; // 10 seconds default
let headerCanHide: boolean = true;
let isToolbarHovered: boolean = false;
let shouldShowToolbarOnHover: boolean = true;

// Tool system state
let currentTool: ToolMode = 'default';
let isDraggingNote: boolean = false;
let draggedNote: HTMLDivElement | null = null;
let resizeHandles: HTMLDivElement[] = [];
let isResizing: boolean = false;
let resizeHandle: HTMLDivElement | null = null;
let resizeStartSize: number = 16; // Initial font size

// Alignment system state
let alignmentCalculator: any | null = null;
let guideRenderer: any | null = null;
let guidesCanvas: HTMLCanvasElement | null = null;
let snapEnabled: boolean = true;
let snapThreshold: number = 8;
let activeGuides: any[] = [];
let lastAlignmentTime: number = 0;
let alignmentDebounceDelay: number = 16; // ~60fps (16ms between frames)
let dragStartPositions: Map<HTMLDivElement, { x: number, y: number }> = new Map();

// Utility functions
function focusCurrentNoteIfSingle(): void {
  if (currentNote && selectedNotes.size <= 1) {
    currentNote.el.focus();
  }
}

function generateTitleFromText(text: string): string {
  if (!text || typeof text !== 'string') {
    return 'Untitled';
  }
  
  // Remove HTML tags and clean up text
  const cleanText = text
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .replace(/\s+/g, ' ')    // Normalize whitespace
    .trim();
  
  if (!cleanText) {
    return 'Untitled';
  }
  
  // Extract first few words, limit to 30 characters
  const words = cleanText.split(' ').filter(word => word.length > 0);
  let title = '';
  
  for (let i = 0; i < Math.min(5, words.length); i++) {
    const nextWord = words[i];
    if (title.length + nextWord.length + (i > 0 ? 1 : 0) <= 30) {
      title += (i > 0 ? ' ' : '') + nextWord;
    } else {
      break;
    }
  }
  
  return title || 'Untitled';
}

function updateUI(): void {
  updateStyles();
  updateToolbar();
}


// Tool management functions
function setToolMode(mode: ToolMode): void {
  currentTool = mode;
  updateCanvasClasses();
  updateToolbarActiveStates();
}

function toggleMoveTool(): void {
  const newTool = currentTool === 'move' ? 'default' : 'move';
  console.log('Smart Align Debug - Tool changed from', currentTool, 'to', newTool);
  setToolMode(newTool);
}


function updateCanvasClasses(): void {
  canvas.classList.toggle('move-mode', currentTool === 'move');
  
  // Update note contentEditable based on tool mode
  canvas.querySelectorAll<HTMLDivElement>('.note').forEach(note => {
    note.contentEditable = currentTool === 'default' ? 'true' : 'false';
  });
  
  // Clear resize handles when switching away from move mode
  if (currentTool !== 'move') {
    clearResizeHandles();
  }
}

function updateToolbarActiveStates(): void {
  const moveToolBtn = $('moveTool') as HTMLButtonElement;
  const snapToggleBtn = $('snapToggle') as HTMLButtonElement;
  
  moveToolBtn.classList.toggle('active', currentTool === 'move');
  snapToggleBtn.classList.toggle('active', snapEnabled);
}

// Resize handles management
function clearResizeHandles(): void {
  resizeHandles.forEach(handle => handle.remove());
  resizeHandles = [];
}

function createResizeHandles(notes: Set<HTMLDivElement>): void {
  clearResizeHandles();
  
  if (notes.size === 0 || currentTool !== 'move') return;
  
  // Calculate bounding box for all selected notes
  let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
  notes.forEach(note => {
    const x = parseInt(note.style.left);
    const y = parseInt(note.style.top);
    const w = note.offsetWidth;
    const h = note.offsetHeight;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
  });
  
  // Create 8 resize handles
  const handlePositions = [
    { class: 'corner-nw', x: minX - 4, y: minY - 4 },
    { class: 'edge-n', x: (minX + maxX) / 2 - 4, y: minY - 4 },
    { class: 'corner-ne', x: maxX - 4, y: minY - 4 },
    { class: 'edge-e', x: maxX - 4, y: (minY + maxY) / 2 - 4 },
    { class: 'corner-se', x: maxX - 4, y: maxY - 4 },
    { class: 'edge-s', x: (minX + maxX) / 2 - 4, y: maxY - 4 },
    { class: 'corner-sw', x: minX - 4, y: maxY - 4 },
    { class: 'edge-w', x: minX - 4, y: (minY + maxY) / 2 - 4 }
  ];
  
  handlePositions.forEach(pos => {
    const handle = document.createElement('div');
    handle.className = `resize-handle ${pos.class}`;
    handle.style.left = pos.x + 'px';
    handle.style.top = pos.y + 'px';
    
    handle.onmousedown = e => {
      e.stopPropagation();
      isResizing = true;
      resizeHandle = handle;
      startX = e.clientX;
      startY = e.clientY;
      
      // Get initial font size from first selected note
      const firstNote = Array.from(selectedNotes)[0];
      if (firstNote && (firstNote as any).__noteData) {
        resizeStartSize = parseInt((firstNote as any).__noteData.styles.fontSize) || 16;
      }
    };
    
    canvas.appendChild(handle);
    resizeHandles.push(handle);
  });
}

function applyStylesAndUpdate(element: HTMLDivElement, styles: NoteStyles): void {
  applyStyles(element, styles);
  updateStyles();
}

function positionCursorInElement(element: HTMLElement): void {
  const range = document.createRange();
  range.selectNodeContents(element);
  range.collapse(false);
  const selection = window.getSelection();
  if (selection) {
    selection.removeAllRanges();
    selection.addRange(range);
  }
}

// Undo/Redo system
let documentHistory: DocumentHistoryState[] = [];
let historyIndex: number = -1;
const MAX_HISTORY: number = 50;

// DOM elements
const $: (id: string) => HTMLElement = (id: string) => {
  const element = document.getElementById(id);
  if (!element) {
    throw new Error(`Element with id "${id}" not found`);
  }
  return element;
};

const appToolbar = $('toolbar') as HTMLDivElement;
const logo = $('logo') as HTMLDivElement;
const canvas = $('canvas') as HTMLDivElement;
const sidebar = $('sidebar') as HTMLDivElement;
const notesList = $('notesList') as HTMLDivElement;
const searchInput = $('searchInput') as HTMLInputElement;
const themeText = $('themeText') as HTMLSpanElement;

// Initialize alignment system
guidesCanvas = $('alignmentGuides') as HTMLCanvasElement;
console.log('Smart Align Debug - Canvas found:', !!guidesCanvas);
console.log('Smart Align Debug - AlignmentCalculator available:', !!(window as any).AlignmentCalculator);
console.log('Smart Align Debug - GuideRenderer available:', !!(window as any).GuideRenderer);

// Helper function to ensure we have test notes for alignment
function ensureTestNotes(): void {
  const existingNotes = canvas.querySelectorAll<HTMLDivElement>('.note');
  console.log('Smart Align Debug - Existing notes:', existingNotes.length);
  
  // Create test notes if we have fewer than 2
  if (existingNotes.length < 2) {
    const positions = [
      { x: 100, y: 100, text: 'Test Note 1' },
      { x: 300, y: 100, text: 'Test Note 2' },
      { x: 200, y: 250, text: 'Test Note 3' }
    ];
    
    positions.slice(existingNotes.length).forEach((pos, index) => {
      const note = document.createElement('div');
      note.className = 'note';
      note.id = `test-note-${existingNotes.length + index}`;
      note.contentEditable = currentTool === 'default' ? 'true' : 'false';
      note.style.left = pos.x + 'px';
      note.style.top = pos.y + 'px';
      note.innerHTML = `<p>${pos.text}</p>`;
      
      const noteObj: NoteObject = {
        el: note,
        styles: {
          bold: false,
          italic: false,
          underline: false,
          strike: false,
          fontSize: '16px',
          fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif',
          align: 'left',
          listType: 'none'
        }
      };
      
      canvas.appendChild(note);
      setupNote(note, noteObj);
      console.log('Smart Align Debug - Created test note:', pos.text, 'at', pos.x, pos.y);
    });
    
    saveCurrentDocument();
  }
}

if (guidesCanvas && (window as any).AlignmentCalculator) {
  alignmentCalculator = new (window as any).AlignmentCalculator({
    snapThreshold,
    snapEnabled,
    showDistances: false,
    guideColors: {
      edge: 'rgba(59, 130, 246, 0.6)',
      center: 'rgba(239, 68, 68, 0.6)',
      spacing: 'rgba(34, 197, 94, 0.6)'
    }
  });
  guideRenderer = new (window as any).GuideRenderer(guidesCanvas);
  console.log('Smart Align Debug - System initialized successfully');
  console.log('Smart Align Debug - Canvas size:', guidesCanvas.width, 'x', guidesCanvas.height);
  
  // Ensure we have test notes for alignment
  setTimeout(() => {
    ensureTestNotes();
  }, 500);
} else {
  console.warn('Smart Align Debug - Failed to initialize:', {
    canvas: !!guidesCanvas,
    calculator: !!(window as any).AlignmentCalculator,
    renderer: !!(window as any).GuideRenderer
  });
}

// Create toolbar hover zone
const toolbarHoverZone = document.createElement('div');
toolbarHoverZone.id = 'toolbarHoverZone';
document.body.appendChild(toolbarHoverZone);

// Theme management
function loadTheme(): void {
  const isDark = localStorage.getItem('darkMode') === 'true';
  document.body.classList.toggle('dark', isDark);
  themeText.textContent = isDark ? 'Dark Mode' : 'Light Mode';
}

// Keyboard shortcuts data
const keyboardShortcuts: KeyboardShortcuts = {
  global: {
    title: "Global Shortcuts",
    shortcuts: [
      {
        action: "New Document",
        mac: "⌘ + N",
        windows: "Ctrl + N"
      },
      {
        action: "Save Document",
        mac: "⌘ + S", 
        windows: "Ctrl + S"
      },
      {
        action: "Undo",
        mac: "⌘ + Z",
        windows: "Ctrl + Z"
      },
      {
        action: "Redo",
        mac: "⌘ + Shift + Z",
        windows: "Ctrl + Shift + Z"
      },
      {
        action: "Select All Notes",
        mac: "⌘ + A",
        windows: "Ctrl + A"
      },
      {
        action: "Clear Selection",
        mac: "Escape",
        windows: "Escape"
      }
    ]
  },
  selection: {
    title: "Selection Shortcuts",
    shortcuts: [
      {
        action: "Copy Selected Notes",
        mac: "⌘ + C",
        windows: "Ctrl + C"
      },
      {
        action: "Paste Notes",
        mac: "⌘ + V",
        windows: "Ctrl + V"
      },
      {
        action: "Duplicate Selected Notes",
        mac: "⌘ + D",
        windows: "Ctrl + D"
      },
      {
        action: "Delete Selected Notes",
        mac: "Delete / Backspace",
        windows: "Delete / Backspace"
      },
      {
        action: "Move Selected Notes",
        mac: "Arrow Keys",
        windows: "Arrow Keys"
      },
      {
        action: "Move Selected Notes (10px)",
        mac: "Shift + Arrow Keys",
        windows: "Shift + Arrow Keys"
      },
      {
        action: "Increase Font Size",
        mac: "⌘ + =",
        windows: "Ctrl + ="
      },
      {
        action: "Decrease Font Size",
        mac: "⌘ + -",
        windows: "Ctrl + -"
      }
    ]
  },
  noteEditing: {
    title: "Note Editing",
    shortcuts: [
      {
        action: "Bold (within note)",
        mac: "⌘ + B",
        windows: "Ctrl + B"
      },
      {
        action: "Italic (within note)",
        mac: "⌘ + I",
        windows: "Ctrl + I"
      },
      {
        action: "Underline (within note)",
        mac: "⌘ + U",
        windows: "Ctrl + U"
      },
      {
        action: "Align Left (within note)",
        mac: "⌘ + L",
        windows: "Ctrl + L"
      },
      {
        action: "Align Center (within note)",
        mac: "⌘ + E",
        windows: "Ctrl + E"
      },
      {
        action: "Align Right (within note)",
        mac: "⌘ + R",
        windows: "Ctrl + R"
      }
    ]
  },
  formatting: {
    title: "Multi-Note Formatting",
    shortcuts: [
      {
        action: "Bold (selected notes)",
        mac: "⌘ + B",
        windows: "Ctrl + B"
      },
      {
        action: "Italic (selected notes)",
        mac: "⌘ + I",
        windows: "Ctrl + I"
      },
      {
        action: "Underline (selected notes)",
        mac: "⌘ + U",
        windows: "Ctrl + U"
      },
      {
        action: "Strikethrough",
        mac: "⌘ + Shift + X",
        windows: "Ctrl + Shift + X"
      },
      {
        action: "Align Left (selected notes)",
        mac: "⌘ + L",
        windows: "Ctrl + L"
      },
      {
        action: "Align Center (selected notes)",
        mac: "⌘ + E",
        windows: "Ctrl + E"
      },
      {
        action: "Align Right (selected notes)",
        mac: "⌘ + R",
        windows: "Ctrl + R"
      },
      {
        action: "Bullet List",
        mac: "⌘ + Shift + 8",
        windows: "Ctrl + Shift + 8"
      },
      {
        action: "Numbered List",
        mac: "⌘ + Shift + 7",
        windows: "Ctrl + Shift + 7"
      }
    ]
  }
};

// Generate shortcuts HTML for the specified platform
function generateShortcutsHTML(platform: Platform): string {
  let html = '';
  
  Object.entries(keyboardShortcuts).forEach(([category, data]) => {
    html += `
      <div class="shortcuts-section">
        <h4>${data.title}</h4>
        <div class="shortcuts-list">
    `;
    
    data.shortcuts.forEach(shortcut => {
      const key = platform === 'mac' ? shortcut.mac : shortcut.windows;
      html += `
        <div class="shortcut-item">
          <span class="shortcut-action">${shortcut.action}</span>
          <span class="shortcut-key">${key}</span>
        </div>
      `;
    });
    
    html += `
        </div>
      </div>
    `;
  });
  
  return html;
}

// Settings management
function loadSettings(): void {
  const saved = localStorage.getItem('anywhereSettings');
  if (saved) {
    const settings: AppSettings = JSON.parse(saved);
    headerIdleTimeout = settings.headerIdleTimeout || 10000;
    headerCanHide = settings.headerCanHide !== false;
  }
}

function saveSettings(): void {
  const settings: AppSettings = {
    headerIdleTimeout,
    headerCanHide
  };
  localStorage.setItem('anywhereSettings', JSON.stringify(settings));
}

// Helper function to show toolbar properly
function showToolbar(): void {
  appToolbar.classList.add('show');
  shouldShowToolbarOnHover = true; // Enable hover zone when toolbar is shown
  resetHeaderTimer();
}

// Header auto-hide system
function resetHeaderTimer(): void {
  if (!headerCanHide) return;
  
  // Clear existing timer
  if (headerIdleTimer) {
    clearTimeout(headerIdleTimer);
  }
  
  // Set new timer to hide toolbar
  headerIdleTimer = window.setTimeout(() => {
    if (headerCanHide && appToolbar.classList.contains('show') && !isToolbarHovered) {
      appToolbar.classList.remove('show');
      shouldShowToolbarOnHover = true; // Keep hover zone active after auto-hide
    }
  }, headerIdleTimeout);
}

function initHeaderAutoHide(): void {
  // Add event listeners for user activity
  const events = ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart'];
  events.forEach(event => {
    document.addEventListener(event, resetHeaderTimer, true);
  });
  
  // Add hover detection for toolbar
  appToolbar.addEventListener('mouseenter', () => {
    isToolbarHovered = true;
  });
  
  appToolbar.addEventListener('mouseleave', () => {
    isToolbarHovered = false;
    // Restart timer when mouse leaves toolbar
    resetHeaderTimer();
  });
  
  // Add hover zone detection to show toolbar when cursor is at top
  toolbarHoverZone.addEventListener('mouseenter', () => {
    // Show toolbar when hovering at top - always show for tool access
    if (shouldShowToolbarOnHover) {
      showToolbar();
    }
  });
  
  // Add mouseleave to restart auto-hide timer when leaving hover zone
  toolbarHoverZone.addEventListener('mouseleave', () => {
    // Restart timer when mouse leaves hover zone (if not over toolbar)
    if (!isToolbarHovered) {
      resetHeaderTimer();
    }
  });
  
  // Start the timer
  resetHeaderTimer();
}

// Document management
function loadDocuments(): void {
  const saved = localStorage.getItem('anywhereDocuments');
  if (saved) documents = JSON.parse(saved);
  
  // Migrate existing documents to include hasCustomTitle flag
  Object.values(documents).forEach(doc => {
    if (doc.hasCustomTitle === undefined) {
      // If title starts with "Note #", it was auto-generated, otherwise it's custom
      doc.hasCustomTitle = !doc.title.startsWith('Note #');
    }
  });
  
  if (!Object.keys(documents).length) {
    createNewDocument();
  } else {
    currentDocId = Object.keys(documents)[0];
    loadDocument(currentDocId);
  }
  updateNotesList();
}

function saveDocuments(): void {
  localStorage.setItem('anywhereDocuments', JSON.stringify(documents));
}

function createNewDocument(): void {
  const id = Date.now().toString();
  documents[id] = { id, title: 'Untitled', notes: [], pinned: false, hasCustomTitle: false };
  currentDocId = id;
  clearCanvas();
  saveDocuments();
  updateNotesList();
}

function clearCanvas(): void {
  canvas.querySelectorAll('.note').forEach(n => n.remove());
  logo.classList.remove('slide-away', 'hidden');
  hasTyped = false;
  selectedNotes.clear();
}

function loadDocument(id: string): void {
  clearCanvas();
  const doc = documents[id];
  if (!doc) return;
  
  currentDocId = id;
  if (doc.notes.length) {
    logo.classList.add('slide-away');
    setTimeout(() => logo.classList.add('hidden'), 500);
    hasTyped = true;
  }
  
  doc.notes.forEach((noteData, index) => {
    const note = document.createElement('div');
    note.className = 'note';
    note.id = `note-${currentDocId}-${index}`;
    note.contentEditable = currentTool === 'default' ? 'true' : 'false';
    note.style.left = noteData.x + 'px';
    note.style.top = noteData.y + 'px';
    note.style.textAlign = noteData.styles.align || 'left';
    note.innerHTML = noteData.html || noteData.text || '';
    
    const noteObj: NoteObject = {
      el: note,
      styles: { ...noteData.styles, align: noteData.styles.align || 'left' }
    };
    
    applyStyles(note, noteData.styles);
    canvas.appendChild(note);
    setupNote(note, noteObj);
  });
  
  updateNotesList();
  updateCanvasClasses(); // Ensure notes respect current tool mode
}

function saveCurrentDocument(): void {
  if (!currentDocId) return;
  
  const notes: NoteData[] = Array.from(canvas.querySelectorAll<HTMLDivElement>('.note')).map(note => {
    const noteData = (note as any).__noteData;
    return {
      x: parseInt(note.style.left),
      y: parseInt(note.style.top),
      text: note.textContent || '',
      html: note.innerHTML || '',
      styles: noteData ? noteData.styles : {
        bold: false,
        italic: false,
        underline: false,
        strike: false,
        fontSize: '16px',
        fontFamily: '-apple-system,BlinkMacSystemFont,\'Segoe UI\',sans-serif',
        align: 'left',
        listType: 'none'
      }
    };
  });
  
  documents[currentDocId].notes = notes;
  
  // Auto-generate title from first note if document hasn't been manually titled
  const currentDoc = documents[currentDocId];
  if (!currentDoc.hasCustomTitle && notes.length > 0) {
    const firstNoteText = notes[0].text;
    if (firstNoteText && firstNoteText.trim()) {
      const newTitle = generateTitleFromText(firstNoteText);
      if (newTitle !== 'Untitled') {
        currentDoc.title = newTitle;
        updateNotesList(); // Update the sidebar display immediately
      }
    }
  }
  
  saveDocuments();
}

// Undo/Redo system functions
function saveToHistory(): void {
  if (!currentDocId) return;
  
  // Create a deep copy of the current document state
  const currentState: DocumentHistoryState = {
    docId: currentDocId,
    notes: JSON.parse(JSON.stringify(documents[currentDocId].notes))
  };
  
  // Remove any history after current index (when undoing then making new changes)
  if (historyIndex < documentHistory.length - 1) {
    documentHistory = documentHistory.slice(0, historyIndex + 1);
  }
  
  // Add new state
  documentHistory.push(currentState);
  
  // Keep history within limits
  if (documentHistory.length > MAX_HISTORY) {
    documentHistory.shift();
  } else {
    historyIndex++;
  }
}

function undo(): boolean {
  if (historyIndex <= 0) return false;
  
  historyIndex--;
  const state = documentHistory[historyIndex];
  
  if (state.docId === currentDocId) {
    // Restore document state
    documents[currentDocId].notes = JSON.parse(JSON.stringify(state.notes));
    loadDocument(currentDocId);
    return true;
  }
  return false;
}

function redo(): boolean {
  if (historyIndex >= documentHistory.length - 1) return false;
  
  historyIndex++;
  const state = documentHistory[historyIndex];
  
  if (state.docId === currentDocId) {
    // Restore document state
    documents[currentDocId].notes = JSON.parse(JSON.stringify(state.notes));
    loadDocument(currentDocId);
    return true;
  }
  return false;
}

// Note list UI
function updateNotesList(): void {
  notesList.innerHTML = '';
  const docs = Object.values(documents)
    .filter(doc => doc.title.toLowerCase().includes(searchInput.value.toLowerCase()));
  
  const pinned = docs.filter(d => d.pinned);
  const unpinned = docs.filter(d => !d.pinned);
  
  if (pinned.length) {
    const section = document.createElement('div');
    section.className = 'pinned-section';
    const title = document.createElement('div');
    title.className = 'pinned-title';
    title.textContent = 'Pinned';
    section.appendChild(title);
    pinned.forEach(doc => section.appendChild(createNoteItem(doc)));
    notesList.appendChild(section);
  }
  
  unpinned.forEach(doc => notesList.appendChild(createNoteItem(doc)));
}

function createNoteItem(doc: AppDocument): HTMLDivElement {
  const item = document.createElement('div');
  item.className = 'note-item';
  if (doc.id === currentDocId) item.classList.add('active');
  
  const textDiv = document.createElement('div');
  textDiv.className = 'note-text';
  const text = document.createElement('span');
  text.textContent = doc.title;
  text.ondblclick = e => {
    e.stopPropagation();
    startInlineEdit();
  };
  textDiv.appendChild(text);
  item.appendChild(textDiv);
  
  // Make entire item clickable
  item.onclick = e => {
    // Don't trigger if clicking on action buttons
    if ((e.target as HTMLElement).closest('.note-actions')) return;
    loadDocument(doc.id);
  };
  
  const actions = document.createElement('div');
  actions.className = 'note-actions';
  
  // Pin button
  const pinBtn = document.createElement('button');
  pinBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="${doc.pinned ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
    <path d="M12 2L9 9H2l6 4-2 7 6-5 6 5-2-7 6-4h-7z"/>
  </svg>`;
  pinBtn.onclick = e => {
    e.stopPropagation();
    doc.pinned = !doc.pinned;
    saveDocuments();
    updateNotesList();
  };
  
  // Edit button
  const editBtn = document.createElement('button');
  editBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
  </svg>`;
  editBtn.onclick = e => {
    e.stopPropagation();
    startInlineEdit();
  };
  
  // Inline edit function
  function startInlineEdit(): void {
    const input = document.createElement('input');
    input.value = doc.title;
    input.onblur = () => {
      if (input.value.trim()) {
        doc.title = input.value.trim();
        doc.hasCustomTitle = true; // Mark as manually titled
        saveDocuments();
      }
      updateNotesList();
    };
    input.onkeydown = e => {
      if (e.key === 'Enter') {
        input.blur();
      } else if (e.key === 'Escape') {
        updateNotesList();
      }
    };
    textDiv.innerHTML = '';
    textDiv.appendChild(input);
    input.focus();
    input.select();
  }
  
  // Delete button
  const delBtn = document.createElement('button');
  delBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <polyline points="3 6 5 6 21 6"/>
    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
  </svg>`;
  delBtn.onclick = e => {
    e.stopPropagation();
    showDeleteModal(doc);
  };
  
  actions.appendChild(pinBtn);
  actions.appendChild(editBtn);
  actions.appendChild(delBtn);
  item.appendChild(actions);
  
  return item;
}

function showDeleteModal(doc: AppDocument): void {
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-content">
      <h3>Delete this note?</h3>
      <p>This action cannot be undone.</p>
      <div class="modal-buttons">
        <button class="cancel">Cancel</button>
        <button class="confirm">OK</button>
      </div>
    </div>
  `;
  
  modal.querySelector<HTMLButtonElement>('.cancel')!.onclick = () => modal.remove();
  modal.querySelector<HTMLButtonElement>('.confirm')!.onclick = () => {
    delete documents[doc.id];
    if (doc.id === currentDocId) {
      const remaining = Object.keys(documents);
      if (remaining.length) {
        loadDocument(remaining[0]);
      } else {
        createNewDocument();
      }
    }
    saveDocuments();
    updateNotesList();
    modal.remove();
  };
  
  document.body.appendChild(modal);
}

function showSettingsModal(): void {
  // Detect user's platform for default preference
  const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
  const defaultPlatform: Platform = isMac ? 'mac' : 'windows';
  const preferredPlatform: Platform = (localStorage.getItem('preferredShortcutPlatform') as Platform) || defaultPlatform;
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-content settings-modal tabbed-modal">
      <button class="modal-close">×</button>
      
      <div class="settings-body">
        <div class="settings-sidebar">
          <div class="settings-tab active" data-tab="options" title="Options">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
            <span>Options</span>
          </div>
          <div class="settings-tab" data-tab="shortcuts" title="Keyboard Shortcuts">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
              <line x1="8" y1="21" x2="16" y2="21"></line>
              <line x1="12" y1="17" x2="12" y2="21"></line>
            </svg>
            <span>Shortcuts</span>
          </div>
        </div>
        
        <div class="settings-content">
          <div class="settings-panel active" id="options-panel">
            <div class="settings-header">
              <h3>General</h3>
              <p class="tab-description">Application settings and preferences</p>
            </div>
            <div class="setting-group">
              <label for="idleTimeInput">Toolbar auto-hide delay (seconds):</label>
              <input type="number" id="idleTimeInput" min="1" max="99" value="${headerIdleTimeout / 1000}">
            </div>
            
            <div class="setting-group">
              <label>
                <input type="checkbox" id="headerToggle" ${headerCanHide ? 'checked' : ''}>
                Allow toolbar to auto-hide
              </label>
            </div>
            
            <div class="setting-group">
              <button class="delete-all-btn" id="deleteAllNotes">Delete All Notes</button>
            </div>
          </div>
          
          <div class="settings-panel" id="shortcuts-panel">
            <div class="settings-header">
              <h3>Shortcuts</h3>
              <p class="tab-description">Keyboard shortcuts and hotkeys</p>
            </div>
            <div class="platform-toggle">
              <span class="toggle-label">Show shortcuts for:</span>
              <div class="toggle-switch">
                <input type="radio" id="platform-mac" name="platform" value="mac" ${preferredPlatform === 'mac' ? 'checked' : ''}>
                <label for="platform-mac">Mac</label>
                <input type="radio" id="platform-windows" name="platform" value="windows" ${preferredPlatform === 'windows' ? 'checked' : ''}>
                <label for="platform-windows">Windows</label>
              </div>
            </div>
            
            <div class="shortcuts-content" id="shortcuts-content">
              ${generateShortcutsHTML(preferredPlatform)}
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
  
  const idleTimeInput = modal.querySelector<HTMLInputElement>('#idleTimeInput')!;
  const headerToggle = modal.querySelector<HTMLInputElement>('#headerToggle')!;
  
  // Close button handler
  modal.querySelector<HTMLButtonElement>('.modal-close')!.onclick = () => modal.remove();
  
  // Tab switching functionality
  const tabs = modal.querySelectorAll('.settings-tab');
  const panels = modal.querySelectorAll('.settings-panel');
  
  tabs.forEach(tab => {
    (tab as HTMLElement).onclick = () => {
      // Remove active class from all tabs and panels
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      
      // Add active class to clicked tab and corresponding panel
      tab.classList.add('active');
      const tabElement = tab as HTMLElement;
      const targetPanel = modal.querySelector(`#${tabElement.dataset.tab}-panel`);
      if (targetPanel) {
        targetPanel.classList.add('active');
      }
    };
  });
  
  // Platform toggle functionality
  const platformRadios = modal.querySelectorAll<HTMLInputElement>('input[name="platform"]');
  const shortcutsContent = modal.querySelector<HTMLDivElement>('#shortcuts-content')!;
  
  platformRadios.forEach(radio => {
    radio.onchange = () => {
      if (radio.checked) {
        shortcutsContent.innerHTML = generateShortcutsHTML(radio.value as Platform);
        localStorage.setItem('preferredShortcutPlatform', radio.value);
      }
    };
  });
  
  // Auto-save functionality
  function autoSaveSettings(): void {
    headerIdleTimeout = parseInt(idleTimeInput.value) * 1000;
    headerCanHide = headerToggle.checked;
    saveSettings();
    
    // Reset header visibility based on new settings
    if (headerCanHide) {
      resetHeaderTimer();
    } else {
      if (headerIdleTimer) {
        clearTimeout(headerIdleTimer);
      }
    }
  }
  
  // Validate number input and auto-save
  idleTimeInput.oninput = () => {
    let value = parseInt(idleTimeInput.value);
    if (isNaN(value) || value < 1) {
      idleTimeInput.value = '1';
    } else if (value > 99) {
      idleTimeInput.value = '99';
    }
    autoSaveSettings();
  };
  
  // Auto-save when checkbox changes
  headerToggle.onchange = autoSaveSettings;
  
  modal.querySelector<HTMLButtonElement>('#deleteAllNotes')!.onclick = () => {
    modal.remove();
    showDeleteAllModal();
  };
  
  document.body.appendChild(modal);
}

function showDeleteAllModal(): void {
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-content">
      <h3>Delete All Notes?</h3>
      <p><strong>This will permanently delete all notes in the current document.</strong></p>
      <p>This action cannot be undone.</p>
      <div class="modal-buttons">
        <button class="cancel">Cancel</button>
        <button class="confirm delete-confirm">Delete All</button>
      </div>
    </div>
  `;
  
  modal.querySelector<HTMLButtonElement>('.cancel')!.onclick = () => modal.remove();
  modal.querySelector<HTMLButtonElement>('.confirm')!.onclick = () => {
    // Clear all notes from current document
    if (currentDocId && documents[currentDocId]) {
      documents[currentDocId].notes = [];
      clearCanvas();
      saveDocuments();
    }
    modal.remove();
  };
  
  document.body.appendChild(modal);
}

// Note setup and interactions
function setupNote(note: HTMLDivElement, noteObj: NoteObject): void {
  (note as any).__noteData = noteObj;
  
  note.addEventListener('mousedown', e => {
    // Use position-based detection to determine if click is over actual text content
    const hasExistingSelection = window.getSelection()?.toString();
    
    // Check if the click position is over text content using Range API
    let isOverTextContent = false;
    try {
      const range = document.caretRangeFromPoint(e.clientX, e.clientY);
      if (range && range.startContainer) {
        // If we can get a valid range and it's within this note, it's over text content
        isOverTextContent = note.contains(range.startContainer) && 
                           (range.startContainer.nodeType === Node.TEXT_NODE || 
                            range.startContainer !== note);
      }
    } catch (err) {
      // Fallback: if Range API fails, allow text selection by default
      isOverTextContent = e.target !== note;
    }
    
    // In move mode, always select the note for moving and enable dragging
    if (currentTool === 'move') {
      console.log('Smart Align Debug - Move mode note click detected');
      if (!e.shiftKey) selectedNotes.clear();
      selectedNotes.add(note);
      updateSelection();
      
      // Enable dragging
      isDraggingNote = true;
      draggedNote = note;
      startX = e.clientX;
      console.log('Smart Align Debug - Individual note drag started');
      startY = e.clientY;
      
      // Initialize alignment system for drag
      if (alignmentCalculator && guideRenderer) {
        // Cache all notes positions (use individual bounds for non-selected notes)
        const allNotes = Array.from(canvas.querySelectorAll<HTMLDivElement>('.note'));
        console.log('Smart Align Debug - Caching bounds for', allNotes.length, 'notes');
        alignmentCalculator.cacheNoteBounds(allNotes);
        
        // Store initial positions of selected notes
        dragStartPositions.clear();
        selectedNotes.forEach(n => {
          dragStartPositions.set(n, {
            x: parseInt(n.style.left) || 0,
            y: parseInt(n.style.top) || 0
          });
        });
        
        // Initialize quadtree for spatial indexing
        alignmentCalculator.initializeQuadTree({
          x: 0,
          y: 0,
          width: window.innerWidth * 2,
          height: window.innerHeight * 2
        });
      }
      
      e.preventDefault();
      return;
    }
    
    // In default mode, handle text selection vs note selection
    if (isOverTextContent && !hasExistingSelection) {
      return; // Let browser handle text selection naturally
    }
    
    // Only handle note selection when clicking on empty areas
    if (e.target === note && !hasExistingSelection && !isOverTextContent) {
      if (!e.shiftKey) selectedNotes.clear();
      selectedNotes.add(note);
      updateSelection();
      e.preventDefault();
    }
  });
  
  note.addEventListener('focus', () => {
    if (currentTool === 'default') {
      currentNote = noteObj;
      showToolbar();
      updateToolbar();
    }
  });
  
  note.addEventListener('blur', () => {
    if (!note.innerHTML.trim()) note.remove();
    saveCurrentDocument();
  });
  
  note.addEventListener('input', () => {
    if (!hasTyped && note.textContent?.length) {
      hasTyped = true;
      logo.classList.add('slide-away');
      setTimeout(() => logo.classList.add('hidden'), 500);
    }
    saveCurrentDocument();
  });
  
  note.addEventListener('mouseup', () => {
    // Show toolbar when text is selected
    if (window.getSelection()?.toString()) {
      currentNote = noteObj;
      showToolbar();
      updateToolbar();
    }
  });
  
  // Handle text selection changes
  note.addEventListener('selectstart', () => {
    // Allow text selection to start naturally
    currentNote = noteObj;
  });
  
  // Note keyboard shortcuts
  note.addEventListener('keydown', e => {
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
    
    if (ctrlKey) {
      switch (e.key.toLowerCase()) {
        case 'b':
          e.preventDefault();
          document.execCommand('bold');
          break;
        case 'i':
          e.preventDefault();
          document.execCommand('italic');
          break;
        case 'u':
          e.preventDefault();
          document.execCommand('underline');
          break;
      }
    }
    
    // List shortcuts with Ctrl+Shift
    if (ctrlKey && e.shiftKey) {
      switch (e.key) {
        case '*':
        case '8':
          e.preventDefault();
          toggleBulletList();
          break;
        case '&':
        case '7':
          e.preventDefault();
          toggleNumberedList();
          break;
      }
    }
  });
}

// Selection management
function updateSelection(): void {
  canvas.querySelectorAll('.note').forEach(n => {
    n.classList.toggle('selected', selectedNotes.has(n as HTMLDivElement));
  });
  
  // Remove old handle
  const oldHandle = canvas.querySelector('.selection-handle');
  if (oldHandle) oldHandle.remove();
  
  if (selectedNotes.size > 1) {
    // Show handle for group dragging
    let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
    selectedNotes.forEach(note => {
      const x = parseInt(note.style.left);
      const y = parseInt(note.style.top);
      const w = note.offsetWidth;
      const h = note.offsetHeight;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + w);
      maxY = Math.max(maxY, y + h);
    });
    
    dragHandle = document.createElement('div');
    dragHandle.className = 'selection-handle';
    dragHandle.style.left = (maxX - 6) + 'px';
    dragHandle.style.top = (maxY - 6) + 'px';
    canvas.appendChild(dragHandle);
    
    dragHandle.onmousedown = e => {
      e.stopPropagation();
      isDraggingGroup = true;
      startX = e.clientX;
      startY = e.clientY;
      console.log('Smart Align Debug - Group drag started');
      
      // Initialize alignment system for group drag
      if (alignmentCalculator && guideRenderer) {
        // Cache all notes positions
        const allNotes = Array.from(canvas.querySelectorAll<HTMLDivElement>('.note'));
        console.log('Smart Align Debug - Caching bounds for group drag:', allNotes.length, 'notes');
        alignmentCalculator.cacheNoteBounds(allNotes);
        
        // Store initial positions of selected notes
        dragStartPositions.clear();
        selectedNotes.forEach(n => {
          dragStartPositions.set(n, {
            x: parseInt(n.style.left) || 0,
            y: parseInt(n.style.top) || 0
          });
        });
        
        // Initialize quadtree for spatial indexing
        alignmentCalculator.initializeQuadTree({
          x: 0,
          y: 0,
          width: window.innerWidth * 2,
          height: window.innerHeight * 2
        });
      }
    };
    
    showToolbar();
    updateToolbar();
  } else if (selectedNotes.size === 1) {
    const note = Array.from(selectedNotes)[0];
    currentNote = (note as any).__noteData!;
    showToolbar();
    updateToolbar();
  } else {
    appToolbar.classList.remove('show');
    shouldShowToolbarOnHover = false; // Disable hover zone when no selection
  }
  
  // Create resize handles in move mode
  if (currentTool === 'move' && selectedNotes.size > 0) {
    createResizeHandles(selectedNotes);
  } else {
    clearResizeHandles();
  }
}

// Styling functions
function applyStyles(el: HTMLDivElement, styles: NoteStyles): void {
  el.style.fontWeight = styles.bold ? 'bold' : 'normal';
  el.style.fontStyle = styles.italic ? 'italic' : 'normal';
  el.style.textDecoration = 
    (styles.underline ? 'underline ' : '') + (styles.strike ? 'line-through' : '');
  el.style.fontSize = styles.fontSize;
  el.style.fontFamily = styles.fontFamily;
  el.style.textAlign = styles.align || 'left';
  
  // Handle list formatting
  if (styles.listType && styles.listType !== 'none') {
    const text = el.textContent || el.innerHTML;
    if (text && !el.querySelector('ul, ol')) {
      // Convert text to list if not already formatted
      const lines = text.split('\n').filter(line => line.trim());
      if (lines.length > 0) {
        const listTag = styles.listType === 'bullet' ? 'ul' : 'ol';
        const listItems = lines.map(line => `<li>${line.trim()}</li>`).join('');
        el.innerHTML = `<${listTag}>${listItems}</${listTag}>`;
      }
    }
  } else if (styles.listType === 'none') {
    // Convert list back to plain text if needed
    const lists = el.querySelectorAll('ul, ol');
    lists.forEach(list => {
      const text = Array.from(list.querySelectorAll('li')).map(li => li.textContent).join('\n');
      list.outerHTML = text;
    });
  }
}

function updateStyles(): void {
  if (selectedNotes.size > 1) {
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
  } else if (currentNote) {
    applyStyles(currentNote.el, currentNote.styles);
  }
  saveCurrentDocument();
}

function toggleBulletList(): void {
  const sel = window.getSelection();
  if (sel?.toString() && sel.rangeCount) {
    // Text is selected - apply to selection
    document.execCommand('insertUnorderedList');
    saveCurrentDocument();
  } else if (selectedNotes.size > 1) {
    // Multiple notes selected
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        const currentListType = (note as any).__noteData.styles.listType;
        const isTogglingOn = currentListType !== 'bullet';
        (note as any).__noteData.styles.listType = isTogglingOn ? 'bullet' : 'none';
        
        // If note is empty and we're turning on list, insert empty list item
        if (isTogglingOn && !note.textContent?.trim()) {
          note.innerHTML = '<ul><li></li></ul>';
          // Position cursor in the list item
          const li = note.querySelector('li');
          if (li) {
            li.focus();
            positionCursorInElement(li);
          }
        } else {
          applyStyles(note, (note as any).__noteData.styles);
        }
      }
    });
    updateStyles();
  } else if (currentNote) {
    // Single note, no selection
    const currentListType = currentNote.styles.listType;
    const isTogglingOn = currentListType !== 'bullet';
    currentNote.styles.listType = isTogglingOn ? 'bullet' : 'none';
    
    // If note is empty and we're turning on list, insert empty list item
    if (isTogglingOn && !currentNote.el.textContent?.trim()) {
      currentNote.el.innerHTML = '<ul><li></li></ul>';
      // Position cursor in the list item
      const li = currentNote.el.querySelector('li');
      if (li) {
        li.focus();
        positionCursorInElement(li);
      }
    } else {
      applyStyles(currentNote.el, currentNote.styles);
    }
    updateStyles();
  }
  updateToolbar();
  focusCurrentNoteIfSingle();
}

function toggleNumberedList(): void {
  const sel = window.getSelection();
  if (sel?.toString() && sel.rangeCount) {
    // Text is selected - apply to selection
    document.execCommand('insertOrderedList');
    saveCurrentDocument();
  } else if (selectedNotes.size > 1) {
    // Multiple notes selected
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        const currentListType = (note as any).__noteData.styles.listType;
        const isTogglingOn = currentListType !== 'numbered';
        (note as any).__noteData.styles.listType = isTogglingOn ? 'numbered' : 'none';
        
        // If note is empty and we're turning on list, insert empty list item
        if (isTogglingOn && !note.textContent?.trim()) {
          note.innerHTML = '<ol><li></li></ol>';
          // Position cursor in the list item
          const li = note.querySelector('li');
          if (li) {
            li.focus();
            positionCursorInElement(li);
          }
        } else {
          applyStyles(note, (note as any).__noteData.styles);
        }
      }
    });
    updateStyles();
  } else if (currentNote) {
    // Single note, no selection
    const currentListType = currentNote.styles.listType;
    const isTogglingOn = currentListType !== 'numbered';
    currentNote.styles.listType = isTogglingOn ? 'numbered' : 'none';
    
    // If note is empty and we're turning on list, insert empty list item
    if (isTogglingOn && !currentNote.el.textContent?.trim()) {
      currentNote.el.innerHTML = '<ol><li></li></ol>';
      // Position cursor in the list item
      const li = currentNote.el.querySelector('li');
      if (li) {
        li.focus();
        positionCursorInElement(li);
      }
    } else {
      applyStyles(currentNote.el, currentNote.styles);
    }
    updateStyles();
  }
  updateToolbar();
  focusCurrentNoteIfSingle();
}

function updateToolbar(): void {
  if (selectedNotes.size > 1) {
    const firstNote = (Array.from(selectedNotes)[0] as any).__noteData;
    if (firstNote) {
      const s = firstNote.styles;
      // Show formatting buttons for multi-selection too
      ($('bold') as HTMLButtonElement).classList.toggle('active', s.bold);
      ($('italic') as HTMLButtonElement).classList.toggle('active', s.italic);
      ($('underline') as HTMLButtonElement).classList.toggle('active', s.underline);
      ($('strike') as HTMLButtonElement).classList.toggle('active', s.strike);
      ($('alignLeft') as HTMLButtonElement).classList.toggle('active', s.align === 'left');
      ($('alignCenter') as HTMLButtonElement).classList.toggle('active', s.align === 'center');
      ($('alignRight') as HTMLButtonElement).classList.toggle('active', s.align === 'right');
      ($('bulletList') as HTMLButtonElement).classList.toggle('active', s.listType === 'bullet');
      ($('numberedList') as HTMLButtonElement).classList.toggle('active', s.listType === 'numbered');
      updateFontSizeInput();
      ($('fontFamily') as HTMLSelectElement).value = s.fontFamily;
    }
  } else if (currentNote) {
    const s = currentNote.styles;
    ($('bold') as HTMLButtonElement).classList.toggle('active', s.bold);
    ($('italic') as HTMLButtonElement).classList.toggle('active', s.italic);
    ($('underline') as HTMLButtonElement).classList.toggle('active', s.underline);
    ($('strike') as HTMLButtonElement).classList.toggle('active', s.strike);
    ($('alignLeft') as HTMLButtonElement).classList.toggle('active', s.align === 'left');
    ($('alignCenter') as HTMLButtonElement).classList.toggle('active', s.align === 'center');
    ($('alignRight') as HTMLButtonElement).classList.toggle('active', s.align === 'right');
    ($('bulletList') as HTMLButtonElement).classList.toggle('active', s.listType === 'bullet');
    ($('numberedList') as HTMLButtonElement).classList.toggle('active', s.listType === 'numbered');
    updateFontSizeInput();
    ($('fontFamily') as HTMLSelectElement).value = s.fontFamily;
  }
}

// Canvas interactions
canvas.addEventListener('mousedown', e => {
  // Existing selection logic
  if (!(e.target as HTMLElement).classList.contains('note') && e.target !== logo && e.target !== dragHandle) {
    isSelecting = true;
    startX = e.clientX;
    startY = e.clientY;
    selectBox = document.createElement('div');
    selectBox.className = 'select-box';
    canvas.appendChild(selectBox);
    if (!e.shiftKey) {
      selectedNotes.clear();
      // Don't update selection immediately - wait for mousemove to add notes
      // This prevents toolbar from hiding during drag selection
    }
  }
});

canvas.addEventListener('mousemove', e => {
  if (isSelecting && selectBox) {
    const x = Math.min(e.clientX, startX);
    const y = Math.min(e.clientY, startY);
    const w = Math.abs(e.clientX - startX);
    const h = Math.abs(e.clientY - startY);
    selectBox.style.left = (x - canvas.offsetLeft) + 'px';
    selectBox.style.top = y + 'px';
    selectBox.style.width = w + 'px';
    selectBox.style.height = h + 'px';
    
    const rect = { left: x, top: y, right: x + w, bottom: y + h };
    let selectionChanged = false;
    const previousSize = selectedNotes.size;
    
    canvas.querySelectorAll<HTMLDivElement>('.note').forEach(note => {
      const nr = note.getBoundingClientRect();
      const shouldBeSelected = nr.left < rect.right && nr.right > rect.left && 
                              nr.top < rect.bottom && nr.bottom > rect.top;
      
      if (shouldBeSelected && !selectedNotes.has(note)) {
        selectedNotes.add(note);
        selectionChanged = true;
      } else if (!shouldBeSelected && !e.shiftKey && selectedNotes.has(note)) {
        selectedNotes.delete(note);
        selectionChanged = true;
      }
    });
    
    // Only update selection if it actually changed
    if (selectionChanged || selectedNotes.size !== previousSize) {
      updateSelection();
    }
  }
});

canvas.addEventListener('mouseup', e => {
  if (isSelecting) {
    isSelecting = false;
    if (selectBox) {
      selectBox.remove();
      selectBox = null;
    }
    // Ensure final selection state is updated
    updateSelection();
    
    // Set flag if we actually selected notes during the drag
    if (selectedNotes.size > 0) {
      justCompletedSelection = true;
      // Clear flag after a short delay to allow click event to check it
      setTimeout(() => { justCompletedSelection = false; }, 50);
    }
  }
});

canvas.addEventListener('click', e => {
  if (e.target === canvas || e.target === logo) {
    // If we just completed a selection, don't clear it or create a new note
    if (justCompletedSelection) {
      return;
    }
    
    // Clear selection if clicking on canvas (unless shift-clicking)
    if (!isSelecting && !e.shiftKey) {
      selectedNotes.clear();
      updateSelection();
    }
    
    // Create new note if clicking on canvas (not logo) and in default mode
    if (e.target !== logo && currentTool === 'default') {
      // Save state before creating new note
      saveToHistory();
      
      const note = document.createElement('div');
      note.className = 'note';
      note.id = `note-${currentDocId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      note.contentEditable = currentTool === 'default' ? 'true' : 'false';
      note.style.left = (e.clientX - canvas.offsetLeft) + 'px';
      note.style.top = e.clientY + 'px';
      
      const noteObj: NoteObject = {
        el: note,
        styles: {
          bold: false,
          italic: false,
          underline: false,
          strike: false,
          fontSize: '16px',
          fontFamily: '-apple-system,BlinkMacSystemFont,\'Segoe UI\',sans-serif',
          align: 'left',
          listType: 'none'
        }
      };
      
      canvas.appendChild(note);
      setupNote(note, noteObj);
      note.focus();
    }
  }
});

// Toolbar interactions
document.addEventListener('click', e => {
  const target = e.target as HTMLElement;
  if (!appToolbar.contains(target) && 
      !target.classList.contains('note') &&
      !(document.activeElement as HTMLElement)?.classList.contains('note') &&
      selectedNotes.size === 0) {
    appToolbar.classList.remove('show');
    shouldShowToolbarOnHover = false; // Disable hover zone when clicking elsewhere
  }
});

document.addEventListener('mousemove', e => {
  // Add general debug info
  if (isDraggingGroup || isDraggingNote) {
    console.log('Smart Align Debug - Drag detected:', {
      isDraggingGroup,
      isDraggingNote,
      currentTool,
      selectedNotesCount: selectedNotes.size,
      alignmentSystemReady: !!(alignmentCalculator && guideRenderer)
    });
  }
  
  if (isDraggingGroup) {
    console.log('Smart Align Debug - Group drag mousemove triggered');
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    // Calculate new positions without applying them yet
    const firstNote = Array.from(selectedNotes)[0];
    const startPos = dragStartPositions.get(firstNote);
    
    // Check if Alt key is held to temporarily disable snapping
    const tempDisableSnap = e.altKey;
    
    // Visual feedback for Alt key
    if (guidesCanvas) {
      guidesCanvas.classList.toggle('snap-disabled', tempDisableSnap);
    }
    canvas.classList.toggle('snap-disabled', tempDisableSnap);
    
    console.log('Smart Align Debug - Group drag alignment check:', {
      alignmentCalculator: !!alignmentCalculator,
      guideRenderer: !!guideRenderer,
      startPos: !!startPos,
      tempDisableSnap,
      altKey: e.altKey
    });
    
    // Performance optimization: debounce alignment calculations
    const currentTime = performance.now();
    const shouldCalculateAlignment = (currentTime - lastAlignmentTime) >= alignmentDebounceDelay;
    
    if (alignmentCalculator && guideRenderer && startPos && !tempDisableSnap && shouldCalculateAlignment) {
      lastAlignmentTime = currentTime;
      console.log('Smart Align Debug - Group drag alignment triggered');
      
      // Calculate the selection box bounds (just like createResizeHandles does)
      let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
      selectedNotes.forEach(note => {
        const x = parseInt(note.style.left) + dx;
        const y = parseInt(note.style.top) + dy;
        const w = note.offsetWidth;
        const h = note.offsetHeight;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + w);
        maxY = Math.max(maxY, y + h);
      });
      
      // Use selection box bounds for alignment
      const draggedBounds: any = {
        id: 'group',
        left: minX,
        top: minY,
        right: maxX,
        bottom: maxY,
        width: maxX - minX,
        height: maxY - minY,
        centerX: (minX + maxX) / 2,
        centerY: (minY + maxY) / 2
      };
      
      console.log('Smart Align Debug - Group bounds:', draggedBounds);
      
      // Get IDs of selected notes to exclude from alignment targets
      const excludeIds = new Set<string>();
      selectedNotes.forEach(n => {
        const id = n.id || n.dataset.noteId || '';
        if (id) excludeIds.add(id);
      });
      
      // Calculate alignments with performance monitoring
      const alignStart = performance.now();
      const guides = alignmentCalculator.calculateAlignments(draggedBounds, excludeIds);
      const alignEnd = performance.now();
      console.log('Smart Align Debug - Group found', guides.length, 'alignment guides in', (alignEnd - alignStart).toFixed(2), 'ms');
      
      // Calculate snap position
      const snapResult = alignmentCalculator.calculateSnapPosition(draggedBounds, guides);
      console.log('Smart Align Debug - Group snap result:', snapResult);
      
      // Apply positions with snap correction
      selectedNotes.forEach(note => {
        const x = parseInt(note.style.left);
        const y = parseInt(note.style.top);
        note.style.left = (x + dx + snapResult.deltaX) + 'px';
        note.style.top = (y + dy + snapResult.deltaY) + 'px';
      });
      
      // Visual feedback for snapping
      if (snapResult.snapped) {
        console.log('Smart Align Debug - SNAPPED! Delta:', snapResult.deltaX, snapResult.deltaY);
        // Brief visual feedback
        if (guidesCanvas) {
          guidesCanvas.classList.add('snap-active');
          setTimeout(() => {
            if (guidesCanvas) guidesCanvas.classList.remove('snap-active');
          }, 200);
        }
      }
      
      // Render guides with visual feedback
      if (snapResult.guides.length > 0) {
        console.log('Smart Align Debug - Rendering', snapResult.guides.length, 'guides');
        guideRenderer.renderGuides(snapResult.guides);
      } else {
        guideRenderer.clear();
      }
    } else {
      // Fallback to normal dragging without alignment
      selectedNotes.forEach(note => {
        const x = parseInt(note.style.left);
        const y = parseInt(note.style.top);
        note.style.left = (x + dx) + 'px';
        note.style.top = (y + dy) + 'px';
      });
      
      // Clear guides if Alt is pressed
      if (tempDisableSnap && guideRenderer) {
        guideRenderer.clear();
      }
    }
    
    if (dragHandle) {
      const hx = parseInt(dragHandle.style.left);
      const hy = parseInt(dragHandle.style.top);
      dragHandle.style.left = (hx + dx) + 'px';
      dragHandle.style.top = (hy + dy) + 'px';
    }
    
    // Update resize handles to follow the notes
    if (currentTool === 'move' && selectedNotes.size > 0) {
      createResizeHandles(selectedNotes);
    }
    
    startX = e.clientX;
    startY = e.clientY;
  }
  
  // Handle individual note dragging in move mode
  if (isDraggingNote && draggedNote) {
    console.log('Smart Align Debug - Individual note drag mousemove triggered');
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    // Calculate alignment and snap for dragged note
    const startPos = dragStartPositions.get(draggedNote);
    
    // Check if Alt key is held to temporarily disable snapping
    const tempDisableSnap = e.altKey;
    
    // Visual feedback for Alt key  
    if (guidesCanvas) {
      guidesCanvas.classList.toggle('snap-disabled', tempDisableSnap);
    }
    canvas.classList.toggle('snap-disabled', tempDisableSnap);
    
    console.log('Smart Align Debug - Individual drag alignment check:', {
      alignmentCalculator: !!alignmentCalculator,
      guideRenderer: !!guideRenderer,
      startPos: !!startPos,
      tempDisableSnap,
      altKey: e.altKey
    });
    
    // Performance optimization: debounce alignment calculations  
    const currentTime = performance.now();
    const shouldCalculateAlignment = (currentTime - lastAlignmentTime) >= alignmentDebounceDelay;
    
    if (alignmentCalculator && guideRenderer && startPos && !tempDisableSnap && shouldCalculateAlignment) {
      lastAlignmentTime = currentTime;
      console.log('Smart Align Debug - Individual note drag alignment triggered');
      
      // Calculate the selection box bounds for single/multiple selected notes
      let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
      selectedNotes.forEach(note => {
        const x = parseInt(note.style.left) + dx;
        const y = parseInt(note.style.top) + dy;
        const w = note.offsetWidth;
        const h = note.offsetHeight;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + w);
        maxY = Math.max(maxY, y + h);
      });
      
      // Use selection box bounds for alignment
      const draggedBounds: any = {
        id: draggedNote.id || draggedNote.dataset.noteId || 'dragged',
        left: minX,
        top: minY,
        right: maxX,
        bottom: maxY,
        width: maxX - minX,
        height: maxY - minY,
        centerX: (minX + maxX) / 2,
        centerY: (minY + maxY) / 2
      };
      
      console.log('Smart Align Debug - Individual bounds:', draggedBounds);
      
      // Get IDs of selected notes to exclude from alignment targets
      const excludeIds = new Set<string>();
      selectedNotes.forEach(n => {
        const id = n.id || n.dataset.noteId || '';
        if (id) excludeIds.add(id);
      });
      
      // Calculate alignments with performance monitoring
      const alignStart = performance.now();
      const guides = alignmentCalculator.calculateAlignments(draggedBounds, excludeIds);
      const alignEnd = performance.now();
      console.log('Smart Align Debug - Individual found', guides.length, 'alignment guides in', (alignEnd - alignStart).toFixed(2), 'ms');
      
      // Calculate snap position
      const snapResult = alignmentCalculator.calculateSnapPosition(draggedBounds, guides);
      console.log('Smart Align Debug - Individual snap result:', snapResult);
      
      // Apply positions with snap correction to all selected notes
      selectedNotes.forEach(note => {
        const x = parseInt(note.style.left);
        const y = parseInt(note.style.top);
        note.style.left = (x + dx + snapResult.deltaX) + 'px';
        note.style.top = (y + dy + snapResult.deltaY) + 'px';
      });
      
      // Visual feedback for snapping
      if (snapResult.snapped) {
        console.log('Smart Align Debug - Individual SNAPPED! Delta:', snapResult.deltaX, snapResult.deltaY);
        // Brief visual feedback
        if (guidesCanvas) {
          guidesCanvas.classList.add('snap-active');
          setTimeout(() => {
            if (guidesCanvas) guidesCanvas.classList.remove('snap-active');
          }, 200);
        }
      }
      
      // Render guides with visual feedback
      if (snapResult.guides.length > 0) {
        console.log('Smart Align Debug - Rendering', snapResult.guides.length, 'guides');
        guideRenderer.renderGuides(snapResult.guides);
      } else {
        guideRenderer.clear();
      }
    } else {
      // Fallback to normal dragging without alignment
      selectedNotes.forEach(note => {
        const x = parseInt(note.style.left);
        const y = parseInt(note.style.top);
        note.style.left = (x + dx) + 'px';
        note.style.top = (y + dy) + 'px';
      });
      
      // Clear guides if Alt is pressed
      if (tempDisableSnap && guideRenderer) {
        guideRenderer.clear();
      }
    }
    
    // Update resize handles to follow the notes
    if (currentTool === 'move' && selectedNotes.size > 0) {
      createResizeHandles(selectedNotes);
    }
    
    startX = e.clientX;
    startY = e.clientY;
  }
  
  // Handle resize
  if (isResizing && resizeHandle && selectedNotes.size > 0) {
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    // Calculate size change based on diagonal movement
    const distance = Math.sqrt(dx * dx + dy * dy);
    const sizeChange = Math.round(distance * 0.2); // Scale factor for font size change
    
    // Determine direction (increase or decrease size)
    const handleClass = resizeHandle.className;
    let newSize = resizeStartSize;
    
    if (handleClass.includes('corner-se') || handleClass.includes('corner-ne')) {
      // Bottom-right or top-right corners: drag right/down to increase
      newSize = resizeStartSize + (dx > 0 ? sizeChange : -sizeChange);
    } else if (handleClass.includes('corner-sw') || handleClass.includes('corner-nw')) {
      // Bottom-left or top-left corners: drag left/up to increase
      newSize = resizeStartSize + (dx < 0 ? sizeChange : -sizeChange);
    } else {
      // Edge handles: use combined movement
      newSize = resizeStartSize + ((dx + dy) > 0 ? sizeChange : -sizeChange);
    }
    
    // Clamp font size between 8px and 72px
    newSize = Math.max(8, Math.min(72, newSize));
    
    // Apply new font size to all selected notes
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        (note as any).__noteData.styles.fontSize = newSize + 'px';
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    
    // Update resize handles position after size change
    createResizeHandles(selectedNotes);
  }
});

document.addEventListener('mouseup', () => {
  if (isDraggingGroup) {
    isDraggingGroup = false;
    saveCurrentDocument();
    
    // Clear alignment guides
    if (guideRenderer) {
      guideRenderer.clear(true); // Fade out
    }
    if (alignmentCalculator) {
      alignmentCalculator.clearCache();
    }
    dragStartPositions.clear();
  }
  
  // Handle note dragging end
  if (isDraggingNote) {
    isDraggingNote = false;
    draggedNote = null;
    saveCurrentDocument();
    
    // Clear alignment guides
    if (guideRenderer) {
      guideRenderer.clear(true); // Fade out
    }
    if (alignmentCalculator) {
      alignmentCalculator.clearCache();
    }
    dragStartPositions.clear();
  }
  
  // Handle resize end
  if (isResizing) {
    isResizing = false;
    resizeHandle = null;
    saveCurrentDocument();
  }
});

// Tool buttons
$('moveTool').onclick = toggleMoveTool;

// Snap toggle button
$('snapToggle').onclick = () => {
  snapEnabled = !snapEnabled;
  
  // Update alignment calculator settings
  if (alignmentCalculator) {
    alignmentCalculator.updateOptions({ snapEnabled });
  }
  
  // Update button visual state
  updateToolbarActiveStates();
  
  // Clear any active guides when disabling
  if (!snapEnabled && guideRenderer) {
    guideRenderer.clear();
  }
};

// Toolbar buttons
['bold', 'italic', 'underline', 'strike'].forEach(id => {
  $(id).onclick = () => {
    const sel = window.getSelection();
    if (sel?.toString() && sel.rangeCount) {
      // Text is selected - apply to selection
      if (id === 'strike') {
        document.execCommand('strikethrough');
      } else {
        document.execCommand(id);
      }
      saveCurrentDocument();
    } else if (selectedNotes.size > 1) {
      // Multiple notes selected
      selectedNotes.forEach(note => {
        if ((note as any).__noteData) {
          ((note as any).__noteData.styles as any)[id] = !((note as any).__noteData.styles as any)[id];
          applyStyles(note, (note as any).__noteData.styles);
        }
      });
      updateStyles();
    } else if (currentNote) {
      // Single note, no selection
      (currentNote.styles as any)[id] = !(currentNote.styles as any)[id];
      applyStylesAndUpdate(currentNote.el, currentNote.styles);
    }
    updateToolbar();
    focusCurrentNoteIfSingle();
  };
});

['alignLeft', 'alignCenter', 'alignRight'].forEach(align => {
  $(align).onclick = () => {
    const alignValue = align.replace('align', '').toLowerCase() as 'left' | 'center' | 'right';
    if (selectedNotes.size > 1) {
      selectedNotes.forEach(note => {
        if ((note as any).__noteData) {
          (note as any).__noteData.styles.align = alignValue;
          applyStyles(note, (note as any).__noteData.styles);
        }
      });
    } else if (currentNote) {
      currentNote.styles.align = alignValue;
      applyStyles(currentNote.el, currentNote.styles);
    }
    updateStyles();
    updateToolbar();
    focusCurrentNoteIfSingle();
  };
});

// List buttons
$('bulletList').onclick = toggleBulletList;
$('numberedList').onclick = toggleNumberedList;

// Font size controls
function applyFontSize(size: string): void {
  const sel = window.getSelection();
  
  if (sel?.toString() && sel.rangeCount) {
    // Apply to selected text
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    span.style.fontSize = size;
    try {
      range.surroundContents(span);
    } catch (e) {
      document.execCommand('fontSize', false, '7');
      const fontElements = currentNote?.el.getElementsByTagName('font');
      if (fontElements) {
        for (let font of fontElements) {
          if ((font as any).size === '7') {
            font.removeAttribute('size');
            font.style.fontSize = size;
          }
        }
      }
    }
    saveCurrentDocument();
  } else if (selectedNotes.size > 1) {
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        (note as any).__noteData.styles.fontSize = size;
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    updateStyles();
  } else if (currentNote) {
    currentNote.styles.fontSize = size;
    applyStylesAndUpdate(currentNote.el, currentNote.styles);
  }
  focusCurrentNoteIfSingle();
}

function updateFontSizeInput(): void {
  const input = $('fontSizeInput') as HTMLInputElement;
  if (selectedNotes.size > 1) {
    const firstNote = (Array.from(selectedNotes)[0] as any).__noteData;
    if (firstNote) {
      input.value = parseInt(firstNote.styles.fontSize).toString();
    }
  } else if (currentNote) {
    input.value = parseInt(currentNote.styles.fontSize).toString();
  }
}

($('fontSizeInput') as HTMLInputElement).onchange = () => {
  const input = $('fontSizeInput') as HTMLInputElement;
  let size = parseInt(input.value);
  
  // Validate and clamp size
  if (isNaN(size) || size < 8) {
    size = 8;
    input.value = '8';
  } else if (size > 72) {
    size = 72;
    input.value = '72';
  }
  
  applyFontSize(size + 'px');
};

($('fontSizeDecrease') as HTMLButtonElement).onclick = () => {
  const input = $('fontSizeInput') as HTMLInputElement;
  let currentSize = parseInt(input.value) || 16;
  const newSize = Math.max(8, currentSize - 1);
  input.value = newSize.toString();
  applyFontSize(newSize + 'px');
};

($('fontSizeIncrease') as HTMLButtonElement).onclick = () => {
  const input = $('fontSizeInput') as HTMLInputElement;
  let currentSize = parseInt(input.value) || 16;
  const newSize = Math.min(72, currentSize + 1);
  input.value = newSize.toString();
  applyFontSize(newSize + 'px');
};

($('fontFamily') as HTMLSelectElement).onchange = () => {
  const font = ($('fontFamily') as HTMLSelectElement).value as FontFamily;
  const sel = window.getSelection();
  
  if (sel?.toString() && sel.rangeCount) {
    // Apply to selected text
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    span.style.fontFamily = font;
    try {
      range.surroundContents(span);
    } catch (e) {
      document.execCommand('fontName', false, font);
    }
    saveCurrentDocument();
  } else if (selectedNotes.size > 1) {
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        (note as any).__noteData.styles.fontFamily = font;
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    updateStyles();
  } else if (currentNote) {
    currentNote.styles.fontFamily = font;
    applyStylesAndUpdate(currentNote.el, currentNote.styles);
  }
  focusCurrentNoteIfSingle();
};

// Sidebar buttons
$('newNote').onclick = createNewDocument;

$('searchBtn').onclick = () => {
  sidebar.classList.toggle('exp');
  if (sidebar.classList.contains('exp')) searchInput.focus();
};

$('libraryBtn').onclick = () => sidebar.classList.toggle('exp');

$('settingsBtn').onclick = () => showSettingsModal();

$('themeToggle').onclick = () => {
  const isDark = document.body.classList.toggle('dark');
  localStorage.setItem('darkMode', isDark.toString());
  themeText.textContent = isDark ? 'Dark Mode' : 'Light Mode';
};

searchInput.oninput = updateNotesList;

// Global keyboard shortcuts
document.addEventListener('keydown', e => {
  const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
  const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
  
  // Handle Escape key to clear selection
  if (e.key === 'Escape' && selectedNotes.size > 0) {
    e.preventDefault();
    selectedNotes.clear();
    updateSelection();
    return;
  }
  
  
  
  // Handle Undo/Redo
  if (ctrlKey && e.key.toLowerCase() === 'z' && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    if (e.shiftKey) {
      redo();
    } else {
      undo();
    }
    return;
  }
  
  // Handle Cmd+N for new document
  if (ctrlKey && e.key.toLowerCase() === 'n' && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    createNewDocument();
    return;
  }
  
  // Handle Cmd+S for save
  if (ctrlKey && e.key.toLowerCase() === 's') {
    e.preventDefault();
    saveCurrentDocument();
    return;
  }
  
  // Handle Cmd+D for duplicate selected notes
  if (ctrlKey && e.key.toLowerCase() === 'd' && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    saveToHistory();
    const offset = 20;
    selectedNotes.forEach(note => {
      const newNote = note.cloneNode(true) as HTMLDivElement;
      const x = parseInt(note.style.left) + offset;
      const y = parseInt(note.style.top) + offset;
      newNote.style.left = x + 'px';
      newNote.style.top = y + 'px';
      
      const noteObj: NoteObject = {
        el: newNote,
        styles: { ...(note as any).__noteData!.styles }
      };
      
      canvas.appendChild(newNote);
      setupNote(newNote, noteObj);
    });
    saveCurrentDocument();
    return;
  }
  
  // Handle font size changes with Cmd+Plus/Minus
  if (ctrlKey && (e.key === '=' || e.key === '+') && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        const currentSize = parseInt((note as any).__noteData.styles.fontSize);
        const newSize = Math.min(currentSize + 2, 72);
        (note as any).__noteData.styles.fontSize = newSize + 'px';
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    updateStyles();
    return;
  }
  
  if (ctrlKey && e.key === '-' && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        const currentSize = parseInt((note as any).__noteData.styles.fontSize);
        const newSize = Math.max(currentSize - 2, 8);
        (note as any).__noteData.styles.fontSize = newSize + 'px';
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    updateStyles();
    return;
  }
  
  // Handle arrow keys to move selected notes
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    const moveDistance = e.shiftKey ? 10 : 1;
    let dx = 0, dy = 0;
    
    switch (e.key) {
      case 'ArrowUp': dy = -moveDistance; break;
      case 'ArrowDown': dy = moveDistance; break;
      case 'ArrowLeft': dx = -moveDistance; break;
      case 'ArrowRight': dx = moveDistance; break;
    }
    
    selectedNotes.forEach(note => {
      const x = parseInt(note.style.left) + dx;
      const y = parseInt(note.style.top) + dy;
      note.style.left = Math.max(0, x) + 'px';
      note.style.top = Math.max(0, y) + 'px';
    });
    
    updateSelection();
    saveCurrentDocument();
    return;
  }
  
  // Handle copy selected notes
  if (ctrlKey && e.key.toLowerCase() === 'c' && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    const notesData = Array.from(selectedNotes).map(note => ({
      x: parseInt(note.style.left),
      y: parseInt(note.style.top),
      html: note.innerHTML,
      styles: (note as any).__noteData ? (note as any).__noteData.styles : {} as NoteStyles
    }));
    
    // Store in localStorage since clipboard API requires HTTPS
    localStorage.setItem('anywhereClipboard', JSON.stringify(notesData));
    return;
  }
  
  // Handle paste notes
  if (ctrlKey && e.key.toLowerCase() === 'v' && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    const clipboardData = localStorage.getItem('anywhereClipboard');
    if (clipboardData) {
      try {
        const notesData = JSON.parse(clipboardData);
        saveToHistory();
        
        selectedNotes.clear();
        const offset = 30;
        
        notesData.forEach((noteData: any, index: number) => {
          const note = document.createElement('div');
          note.className = 'note';
          note.id = `note-${currentDocId}-paste-${Date.now()}-${index}`;
          note.contentEditable = currentTool === 'default' ? 'true' : 'false';
          note.style.left = (noteData.x + offset) + 'px';
          note.style.top = (noteData.y + offset) + 'px';
          note.innerHTML = noteData.html;
          
          const noteObj: NoteObject = {
            el: note,
            styles: { ...noteData.styles }
          };
          
          applyStyles(note, noteData.styles);
          canvas.appendChild(note);
          setupNote(note, noteObj);
          selectedNotes.add(note);
        });
        
        updateSelection();
        saveCurrentDocument();
      } catch (e) {
        console.warn('Failed to paste notes:', e);
      }
    }
    return;
  }
  
  // Handle selected notes deletion
  if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    // Save state before deletion
    saveToHistory();
    selectedNotes.forEach(note => note.remove());
    selectedNotes.clear();
    updateSelection();
    saveCurrentDocument();
    return;
  }
  
  // Handle Ctrl+A to select all notes
  if (ctrlKey && e.key.toLowerCase() === 'a' && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    selectedNotes.clear();
    canvas.querySelectorAll<HTMLDivElement>('.note').forEach(note => selectedNotes.add(note));
    updateSelection();
    return;
  }
  
  // Existing shortcuts for active note
  if (ctrlKey && currentNote && (document.activeElement as HTMLElement).classList.contains('note')) {
    switch (e.key.toLowerCase()) {
      case 'e':
        e.preventDefault();
        ($('alignCenter') as HTMLButtonElement).click();
        break;
      case 'l':
        e.preventDefault();
        ($('alignLeft') as HTMLButtonElement).click();
        break;
      case 'r':
        e.preventDefault();
        ($('alignRight') as HTMLButtonElement).click();
        break;
    }
  }
  
  // Keyboard shortcuts for selected notes (when no note is being edited)
  if (ctrlKey && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    switch (e.key.toLowerCase()) {
      case 'b':
        e.preventDefault();
        ($('bold') as HTMLButtonElement).click();
        break;
      case 'i':
        e.preventDefault();
        ($('italic') as HTMLButtonElement).click();
        break;
      case 'u':
        e.preventDefault();
        ($('underline') as HTMLButtonElement).click();
        break;
      case 'e':
        e.preventDefault();
        ($('alignCenter') as HTMLButtonElement).click();
        break;
      case 'l':
        e.preventDefault();
        ($('alignLeft') as HTMLButtonElement).click();    
        break;
      case 'r':
        e.preventDefault();
        ($('alignRight') as HTMLButtonElement).click();
        break;
    }
  }
  
  // List keyboard shortcuts
  if (ctrlKey && e.shiftKey && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    switch (e.key) {
      case '*':
      case '8':
        e.preventDefault();
        ($('bulletList') as HTMLButtonElement).click();
        break;
      case '&':
      case '7':
        e.preventDefault();
        ($('numberedList') as HTMLButtonElement).click();
        break;
    }
  }
});



// Initialize
loadTheme();
loadSettings();
loadDocuments();
initHeaderAutoHide();
updateCanvasClasses(); // Initialize tool state
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**Anyplace** is a freeform note-taking application built with TypeScript, HTML, and CSS. It provides an infinite canvas where users can click anywhere to create text notes with rich formatting options.

## Architecture

### Core Components

- **Canvas System**: The main infinite workspace where notes are positioned absolutely
- **Note Management**: Each note is a contentEditable div with persistent styling and positioning
- **Document System**: Multiple documents/pages with save/load functionality via localStorage
- **State Management**: Global state variables track current note, document, and UI state

### Key Modules

- **Document Management** (`loadDocuments`, `saveDocuments`, `createNewDocument`): Handles multiple note documents with localStorage persistence
- **Note Operations** (`setupNote`, `applyStyles`, `updateStyles`): Individual note creation, editing, and formatting
- **Selection System** (`updateSelection`, selection box): Multi-note selection with group operations
- **Toolbar System**: Floating formatting toolbar with drag functionality
- **Sidebar System**: Collapsible sidebar with document browser, search, and theme toggle

### Data Structure

```typescript
interface Document {
  id: string;
  title: string;
  notes: NoteData[];
  pinned: boolean;
  hasCustomTitle?: boolean;
}

interface NoteData {
  x: number;
  y: number;
  text: string;
  html: string;
  styles: NoteStyles;
}

interface NoteStyles {
  bold: boolean;
  italic: boolean;
  underline: boolean;
  strike: boolean;
  fontSize: string;
  fontFamily: string;
  align: 'left' | 'center' | 'right';
  listType: 'none' | 'bullet' | 'numbered';
}
```

## Development Commands

The project now uses TypeScript for enhanced type safety and developer experience:

- **Build**: `npm run build` - Compiles TypeScript to JavaScript in `/dist` folder
- **Watch Mode**: `npm run watch` - Automatically recompile TypeScript on changes
- **Development**: Open `src/index.html` in a browser (references compiled JS from `/dist`)
- **Local Server**: `npm run serve` - Serves application on localhost:8080
- **Testing**: Manual testing in browser - no automated test suite yet

## Key Features

- **Infinite Canvas**: Click anywhere to create a note
- **Rich Text Formatting**: Bold, italic, underline, strikethrough, font size/family, alignment
- **Multi-selection**: Shift+click or drag selection box for group operations
- **Document Management**: Multiple documents with search, pinning, and organization
- **Persistence**: All data saved to localStorage automatically
- **Theme System**: Light/dark mode toggle
- **Responsive Sidebar**: Collapsible document browser
- **Keyboard Shortcuts**: Standard text formatting shortcuts (Ctrl/Cmd+B, I, U, etc.)

## File Structure

```
src/
├── index.html     # Main application structure and UI
├── app.ts         # Core application logic and interactions (TypeScript)
├── types.ts       # TypeScript type definitions
└── styles.css     # Complete styling including dark theme
dist/
├── app.js         # Compiled JavaScript (generated)
├── app.js.map     # Source map for debugging
├── types.js       # Compiled type definitions
└── types.js.map   # Source map for types
```

## State Management Patterns

- **Global Variables**: All state managed through typed global variables at top of app.ts
- **Event-Driven**: Heavy use of DOM event listeners for interactions
- **Auto-Save**: Document changes trigger automatic localStorage updates
- **Theme Persistence**: Theme preference saved to localStorage
- **Type Safety**: All data structures and functions are fully typed for better reliability

## UI Interaction Patterns

- **Canvas Click**: Creates new note at click position
- **Note Focus**: Shows formatting toolbar
- **Toolbar Dragging**: Toolbar can be repositioned by dragging
- **Selection Box**: Drag on empty canvas to select multiple notes
- **Group Operations**: Selected notes can be moved and formatted together
</file>

<file path="src/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Anyplace</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="sidebar">
  <div class="sidebar-logo">
    <span class="logo-full">Anyplace</span>
    <span class="logo-short">A</span>
  </div>
  <button class="sb-btn" id="libraryBtn">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <rect x="3" y="3" width="18" height="18" rx="2"></rect>
      <line x1="9" y1="3" x2="9" y2="21"></line>
    </svg>
    <span>Toggle Sidebar</span>
  </button>
  <button class="sb-btn" id="newNote">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="12" y1="5" x2="12" y2="19"></line>
      <line x1="5" y1="12" x2="19" y2="12"></line>
    </svg>
    <span>New Note</span>
  </button>
  <button class="sb-btn" id="searchBtn">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="11" cy="11" r="8"></circle>
      <path d="m21 21-4.35-4.35"></path>
    </svg>
    <span>Search Notes</span>
  </button>
  <input type="text" id="searchInput" placeholder="Search notes...">
  <div id="notesList"></div>
  <div class="sb-footer">
    <button class="sb-btn" id="settingsBtn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
      <span>Settings</span>
    </button>
    <button class="sb-btn" id="themeToggle">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
      </svg>
      <span id="themeText">Light Mode</span>
    </button>
  </div>
</div>

<div id="canvas">
  <div id="logo">Anyplace<div id="logo-subtext">Your ideas anywhere, anyplace</div></div>
</div>

<canvas id="alignmentGuides"></canvas>

<div id="toolbar">
  <button id="moveTool" title="Move Tool">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/>
      <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/>
      <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/>
      <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.83L8 15"/>
    </svg>
  </button>
  <button id="snapToggle" title="Toggle Alignment Guides (Alt to temporarily disable)" class="active">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <rect x="3" y="3" width="7" height="7"/>
      <rect x="14" y="3" width="7" height="7"/>
      <rect x="14" y="14" width="7" height="7"/>
      <rect x="3" y="14" width="7" height="7"/>
      <line x1="12" y1="3" x2="12" y2="21" stroke-dasharray="2 2"/>
      <line x1="3" y1="12" x2="21" y2="12" stroke-dasharray="2 2"/>
    </svg>
  </button>
  <div class="sep"></div>
  <button id="bold"><b>B</b></button>
  <button id="italic"><i>I</i></button>
  <button id="underline"><u>U</u></button>
  <button id="strike"><s>S</s></button>
  <div class="sep"></div>
  <button id="alignLeft" title="Align Left">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="3" y1="6" x2="21" y2="6"/>
      <line x1="3" y1="12" x2="15" y2="12"/>
      <line x1="3" y1="18" x2="18" y2="18"/>
    </svg>
  </button>
  <button id="alignCenter" title="Align Center">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="3" y1="6" x2="21" y2="6"/>
      <line x1="6" y1="12" x2="18" y2="12"/>
      <line x1="4" y1="18" x2="20" y2="18"/>
    </svg>
  </button>
  <button id="alignRight" title="Align Right">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="3" y1="6" x2="21" y2="6"/>
      <line x1="9" y1="12" x2="21" y2="12"/>
      <line x1="6" y1="18" x2="21" y2="18"/>
    </svg>
  </button>
  <div class="sep"></div>
  <button id="bulletList" title="Bullet List">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="3" cy="6" r="1"/>
      <line x1="7" y1="6" x2="21" y2="6"/>
      <circle cx="3" cy="12" r="1"/>
      <line x1="7" y1="12" x2="21" y2="12"/>
      <circle cx="3" cy="18" r="1"/>
      <line x1="7" y1="18" x2="21" y2="18"/>
    </svg>
  </button>
  <button id="numberedList" title="Numbered List">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="10" y1="6" x2="21" y2="6"/>
      <line x1="10" y1="12" x2="21" y2="12"/>
      <line x1="10" y1="18" x2="21" y2="18"/>
      <path d="M4 6h1v4"/>
      <path d="M4 10h2"/>
      <path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"/>
    </svg>
  </button>
  <div class="sep"></div>
  <div class="font-size-controls">
    <button id="fontSizeDecrease" title="Decrease font size">−</button>
    <input id="fontSizeInput" type="number" min="8" max="72" value="16" title="Font size">
    <button id="fontSizeIncrease" title="Increase font size">+</button>
  </div>
  <select id="fontFamily">
    <option value="-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif">System Default</option>
    <option value="Arial,Helvetica,sans-serif">Arial</option>
    <option value="'Helvetica Neue',Helvetica,sans-serif">Helvetica</option>
    <option value="Verdana,Geneva,sans-serif">Verdana</option>
    <option value="'Trebuchet MS',sans-serif">Trebuchet MS</option>
    <option value="'Lucida Sans',sans-serif">Lucida Sans</option>
    <option value="Tahoma,Geneva,sans-serif">Tahoma</option>
    <option value="'Segoe UI',Tahoma,Geneva,sans-serif">Segoe UI</option>
    <option value="Georgia,'Times New Roman',serif">Georgia</option>
    <option value="'Times New Roman',Times,serif">Times New Roman</option>
    <option value="'Book Antiqua',Palatino,serif">Book Antiqua</option>
    <option value="Garamond,serif">Garamond</option>
    <option value="'Courier New',Courier,monospace">Courier New</option>
    <option value="Monaco,'Lucida Console',monospace">Monaco</option>
    <option value="Consolas,'Liberation Mono',monospace">Consolas</option>
    <option value="'Fira Code',monospace">Fira Code</option>
    <option value="Impact,'Arial Black',sans-serif">Impact</option>
    <option value="'Comic Sans MS',cursive">Comic Sans MS</option>
    <option value="Papyrus,fantasy">Papyrus</option>
    <option value="'Brush Script MT',cursive">Brush Script</option>
  </select>
</div>

<script src="../dist/alignment.js"></script>
<script src="../dist/app.js"></script>
</body>
</html>
</file>

<file path="src/styles.css">
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  :root {
    --bg: #fafafa;
    --txt: #333;
    --sb: #344532;
    --st: #ccc;
    --sh: rgba(255, 255, 255, 0.1);
    --nf: rgba(255, 255, 255, 0.5);
    --nb: rgba(0, 0, 0, 0.1);
    --tb: rgba(52, 69, 50, 0.9);
    --ts: rgba(0, 0, 0, 0.1);
    --th: rgba(0, 0, 0, 0.05);
    --ta: rgba(0, 0, 0, 0.1);
    --ib: #1a1a1a;
    --bd: #444;
    --lc: #ccc;
  }
  
  body.dark {
    --bg: #1a1a1a;
    --txt: #e0e0e0;
    --sb: #2d3c2a;
    --nf: rgba(255, 255, 255, 0.1);
    --nb: rgba(255, 255, 255, 0.2);
    --tb: rgba(45, 60, 42, 0.9);
    --ts: rgba(0, 0, 0, 0.3);
    --th: rgba(255, 255, 255, 0.1);
    --ta: rgba(255, 255, 255, 0.2);
    --ib: #000;
    --bd: #555;
    --lc: #666;
  }
  
  body {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--txt);
    transition: background 0.3s, color 0.3s;
  }
  
  /* Logo */
  #logo {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 60px;
    font-weight: 300;
    color: var(--lc);
    pointer-events: none;
    font-family: Georgia, serif;
    letter-spacing: 0.05em;
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
    text-align: center;
  }

  #logo-subtext {
    font-size: 20px;
    font-weight: 300;
    color: var(--lc);
    font-family: Georgia, serif;
    letter-spacing: 0.05em;
    margin-top: 12px;
    opacity: 0.8;
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
  }
  
  #logo.slide-away {
    top: -60px;
    left: -200px;
    transform: none;
    font-size: 30px;
    opacity: 0;
  }

  #logo.slide-away #logo-subtext {
    opacity: 0;
  }
  
  #logo.hidden {
    display: none;
  }
  
  /* Sidebar Logo */
  .sidebar-logo {
    padding: 14px;
    font-size: 18px;
    font-weight: 300;
    color: #fff;
    font-family: Georgia, serif;
    letter-spacing: 0.05em;
    text-align: center;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .logo-full {
    display: none;
  }
  
  .logo-short {
    display: block;
  }
  
  #sidebar.exp .logo-full {
    display: block;
  }
  
  #sidebar.exp .logo-short {
    display: none;
  }
  
  
  /* Notes */
  .note {
    position: absolute;
    outline: none;
    border: none;
    background: transparent;
    min-width: 20px;
    min-height: 20px;
    padding: 2px;
    cursor: text;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: var(--txt);
  }
  
  .note:focus {
  }
  
  .note.selected {
    background: rgba(52, 69, 50, 0.1);
    box-shadow: 0 0 0 2px rgba(52, 69, 50, 0.5);
  }

  /* List styling */
  .note ul {
    margin: 0;
    padding-left: 20px;
    list-style-type: disc;
  }

  .note ol {
    margin: 0;
    padding-left: 20px;
    list-style-type: decimal;
  }

  .note li {
    margin: 2px 0;
  }
  
  /* Toolbar */
  #toolbar {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--tb);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 8px;
    box-shadow: 0 2px 20px var(--ts);
    padding: 8px 12px;
    display: flex;
    gap: 8px;
    align-items: center;
    transition: top 0.3s ease;
    z-index: 1000;
  }
  
  #toolbar.show {
    top: 20px;
  }

  /* Toolbar hover zone - invisible area at top to reveal toolbar */
  #toolbarHoverZone {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 100px;
    z-index: 999;
    pointer-events: auto;
    background: transparent;
  }
  
  #toolbar button {
    background: none;
    border: none;
    padding: 6px 10px;
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    transition: background 0.2s;
    color: #ffffff;
  }
  
  #toolbar button:hover {
    background: var(--th);
  }
  
  #toolbar button.active {
    background: var(--ta);
  }
  
  #toolbar select {
    padding: 4px 8px;
    border: 1px solid var(--bd);
    border-radius: 4px;
    background: rgba(52, 69, 50, 0.95);
    color: #ffffff;
    cursor: pointer;
    font-size: 14px;
    outline: none;
  }
  
  .font-size-controls {
    display: flex;
    align-items: center;
    gap: 2px;
  }
  
  .font-size-controls button {
    width: 24px;
    height: 24px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: bold;
    line-height: 1;
  }
  
  .font-size-controls input {
    width: 50px;
    padding: 4px 6px;
    border: 1px solid var(--bd);
    border-radius: 4px;
    background: rgba(52, 69, 50, 0.95);
    color: #ffffff;
    font-size: 14px;
    text-align: center;
    outline: none;
    -moz-appearance: textfield;
  }
  
  .font-size-controls input::-webkit-outer-spin-button,
  .font-size-controls input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  
  .sep {
    width: 1px;
    height: 20px;
    background: var(--bd);
  }
  
  /* Sidebar */
  #sidebar {
    position: fixed;
    left: 0;
    top: 0;
    height: 100vh;
    width: 48px;
    background: var(--sb);
    transition: width 0.3s ease;
    z-index: 1001;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  
  
  #sidebar.exp {
    width: 260px;
  }
  
  .sb-btn {
    width: 100%;
    height: 48px;
    background: none;
    border: none;
    color: var(--st);
    cursor: pointer;
    display: flex;
    align-items: center;
    padding: 0 14px;
    transition: background 0.2s;
    flex-shrink: 0;
    overflow: hidden;
  }
  
  
  .sb-btn:hover {
    background: var(--sh);
  }
  
  .sb-btn svg {
    width: 20px;
    height: 20px;
    flex-shrink: 0;
  }
  
  .sb-btn span {
    margin-left: 20px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.3s;
  }
  
  #sidebar.exp .sb-btn span {
    opacity: 1;
  }
  
  #searchInput {
    width: calc(100% - 28px);
    margin: 10px 14px;
    padding: 12px;
    border: none;
    background: transparent;
    color: var(--st);
    border-radius: 0;
    border-bottom: 1px solid var(--sh);
    display: none;
    font-size: 14px;
    outline: none;
  }
  
  #searchInput::placeholder {
    color: rgba(204, 204, 204, 0.6);
  }
  
  #sidebar.exp #searchInput {
    display: block;
  }
  
  #notesList {
    flex: 1;
    
    display: none;
    padding: 10px;
  }
  
  #sidebar.exp #notesList {
    display: block;
  }
  
  .note-item {
    padding: 10px;
    margin-bottom: 5px;
    background: var(--sh);
    border-radius: 4px;
    cursor: pointer;
    color: var(--st);
    transition: background 0.2s;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  
  .note-item:hover {
    background: rgba(255, 255, 255, 0.15);
  }
  
  .note-item:hover .note-actions {
    opacity: 1;
  }
  
  .note-item.active {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
  }
  
  .note-text {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .note-text input {
    background: transparent;
    border: 1px solid var(--bd);
    padding: 2px 6px;
    color: inherit;
    font: inherit;
    width: 100%;
    border-radius: 3px;
  }
  
  .note-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
  }
  
  .note-actions button {
    background: none;
    border: none;
    padding: 4px;
    cursor: pointer;
    color: var(--st);
    border-radius: 3px;
    transition: background 0.2s;
  }
  
  .note-actions button:hover {
    background: var(--sh);
  }
  
  .note-actions svg {
    width: 16px;
    height: 16px;
  }
  
  .pinned-section {
    border-bottom: 1px solid var(--sh);
    margin-bottom: 10px;
    padding-bottom: 10px;
  }
  
  .pinned-title {
    font-size: 12px;
    text-transform: uppercase;
    color: var(--st);
    margin-bottom: 8px;
    opacity: 0.7;
  }
  
  /* Canvas */
  #canvas {
    position: absolute;
    top: 0;
    left: 48px;
    right: 0;
    bottom: 0;
    cursor: crosshair;
    transition: left 0.3s ease;
  }
  
  #sidebar.exp ~ #canvas {
    left: 260px;
  }

  /* Alignment guides canvas */
  #alignmentGuides {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 100;
    opacity: 1;
    transition: opacity 0.15s ease-out;
  }

  #alignmentGuides.fading {
    opacity: 0;
  }
  
  #alignmentGuides.snap-disabled {
    opacity: 0.3;
    filter: grayscale(100%);
  }
  
  /* Visual feedback for snapping */
  #alignmentGuides.snap-active {
    filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.4));
  }
  
  /* Cursor feedback when snapping is disabled */
  #canvas.move-mode.snap-disabled {
    cursor: not-allowed !important;
  }
  
  #canvas.move-mode.snap-disabled .note {
    cursor: not-allowed !important;
  }

  /* Tool-specific cursor styles */
  #canvas.move-mode {
    cursor: default;
  }

  /* Move tool cursor when hovering over notes */
  #canvas.move-mode .note {
    cursor: move !important;
  }
  
  .sb-footer {
    margin-top: auto;
    border-top: 1px solid var(--sh);
  }
  
  /* Selection */
  .select-box {
    position: absolute;
    border: 1px dashed rgba(52, 69, 50, 0.7);
    background: rgba(52, 69, 50, 0.1);
    pointer-events: none;
  }
  
  .selection-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    background: #344532;
    border: 2px solid #fff;
    border-radius: 2px;
    cursor: move;
    z-index: 100;
  }

  .resize-handle {
    position: absolute;
    width: 8px;
    height: 8px;
    background: #344532;
    border: 1px solid #fff;
    border-radius: 1px;
    z-index: 101;
  }

  .resize-handle.corner-nw { cursor: nw-resize; }
  .resize-handle.corner-ne { cursor: ne-resize; }
  .resize-handle.corner-sw { cursor: sw-resize; }
  .resize-handle.corner-se { cursor: se-resize; }
  .resize-handle.edge-n { cursor: n-resize; }
  .resize-handle.edge-s { cursor: s-resize; }
  .resize-handle.edge-w { cursor: w-resize; }
  .resize-handle.edge-e { cursor: e-resize; }
  
  /* Modal */
  .modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
  }
  
  .modal-content {
    background: var(--sb);
    border-radius: 8px;
    padding: 24px;
    max-width: 400px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }
  
  .modal-content h3 {
    color: #fff;
    margin-bottom: 16px;
    text-align: left;
  }
  
  .modal-content p {
    color: var(--st);
    margin-bottom: 20px;
    text-align: left;
  }
  
  .modal-buttons {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
  }
  
  .modal-buttons button {
    padding: 8px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
  }
  
  .modal-buttons .cancel {
    background: #ffffff;
    border: 1px solid #cccccc;
    color: #333333;
  }
  
  .modal-buttons .confirm {
    background: #2a3628;
    color: #fff;
  }
  
  .modal-buttons button:hover {
    transform: translateY(-1px);
  }

  /* Settings Modal */
  .settings-modal {
    width: 680px;
    height: 600px;
    min-width: 680px;
    max-width: 680px;
    min-height: 600px;
    max-height: 600px;
    padding: 0;
    background: #344532;
    position: relative;
    overflow: hidden;
    box-sizing: border-box;
  }
  
  .tabbed-modal {
    display: flex;
    flex-direction: row;
    height: 600px;
    min-height: 600px;
    max-height: 600px;
  }
  
  .settings-modal .settings-header {
    padding: 32px 0 24px 0;
    margin-bottom: 0;
    text-align: left !important;
    display: block;
    width: 100%;
  }
  
  .settings-modal .settings-header h3 {
    margin: 0 0 8px 0;
    color: #fff;
    font-size: 18px;
    font-weight: 500;
    text-align: left !important;
    display: block;
    width: 100%;
  }
  
  .settings-modal .settings-header .tab-description {
    margin: 0 0 24px 0;
    color: var(--st);
    font-size: 14px;
    font-weight: 400;
    padding-bottom: 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    text-align: left !important;
    display: block;
    width: 100%;
  }
  
  /* Additional specific selectors for the settings panels */
  .settings-modal .settings-panel h3 {
    text-align: left !important;
  }
  
  .settings-modal .settings-panel p {
    text-align: left !important;
  }
  
  .settings-modal .settings-panel .tab-description {
    text-align: left !important;
  }
  
  .modal-close {
    position: absolute;
    top: 18px;
    left: 18px;
    background: none;
    border: none;
    color: var(--st);
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background 0.2s;
    z-index: 10;
  }
  
  .modal-close:hover {
    background: var(--bd);
  }
  
  .settings-body {
    display: flex;
    height: 600px;
    min-height: 600px;
    max-height: 600px;
  }
  
  .settings-sidebar {
    width: 60px;
    background: var(--sh);
    padding: 60px 0 0 0;
    display: flex;
    flex-direction: column;
    position: relative;
    flex-shrink: 0;
    height: 600px;
  }
  
  .settings-tab {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 18px 0;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    margin-bottom: 4px;
  }
  
  .settings-tab:hover {
    background: rgba(255, 255, 255, 0.1);
  }
  
  .settings-tab.active {
    background: #344532;
    color: #fff;
  }
  
  .settings-tab svg {
    width: 24px;
    height: 24px;
    stroke: currentColor;
  }
  
  .settings-tab span {
    display: none;
  }
  
  .settings-content {
    flex: 1 1 auto;
    overflow-y: auto;
    min-height: 0;
    width: 620px;
  }
  
  /* Custom Scrollbar for Settings Content */
  .settings-content::-webkit-scrollbar {
    width: 8px;
  }
  
  .settings-content::-webkit-scrollbar-track {
    background: transparent;
  }
  
  .settings-content::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
  }
  
  .settings-content::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }
  
  .settings-panel {
    display: none;
    padding: 0 32px 32px 32px;
  }
  
  .settings-panel.active {
    display: block;
  }
  
  /* Platform Toggle */
  .platform-toggle {
    margin-bottom: 24px;
  }
  
  .toggle-label {
    color: #fff;
    font-weight: 500;
    margin-bottom: 12px;
    display: block;
  }
  
  .toggle-switch {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .toggle-switch input[type="radio"] {
    display: none;
  }
  
  .toggle-switch label {
    padding: 8px 16px;
    background: var(--bd);
    color: var(--st);
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
    border: 1px solid var(--bd);
  }
  
  .toggle-switch label:hover {
    background: var(--sh);
  }
  
  .toggle-switch input[type="radio"]:checked + label {
    background: #344532;
    color: #fff;
    border-color: #344532;
  }
  
  /* Shortcuts Layout */
  .shortcuts-content {
    /* No custom height or overflow - let parent handle scrolling */
  }
  
  .shortcuts-section {
    margin-bottom: 32px;
  }
  
  .shortcuts-section:last-child {
    margin-bottom: 0;
  }
  
  .shortcuts-section h4 {
    color: #fff;
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 16px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  .shortcuts-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .shortcut-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
  }
  
  .shortcut-action {
    color: var(--st);
    font-size: 14px;
  }
  
  .shortcut-key {
    color: #fff;
    font-size: 12px;
    font-family: 'Courier New', monospace;
    background: var(--sh);
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    font-weight: 500;
  }
  

  .setting-group {
    margin-bottom: 24px;
  }

  .setting-group:last-child {
    margin-bottom: 0;
  }

  .setting-group label {
    display: block;
    color: #fff;
    margin-bottom: 12px;
    font-weight: 500;
    font-size: 14px;
  }

  .setting-group input[type="range"] {
    width: 100%;
    height: 6px;
    background: var(--bd);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
    appearance: none;
  }

  .setting-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: #344532;
    border-radius: 50%;
    cursor: pointer;
  }

  .setting-group input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: #344532;
    border-radius: 50%;
    cursor: pointer;
    border: none;
  }

  .setting-group input[type="checkbox"] {
    margin-right: 8px;
    transform: scale(1.2);
  }

  .setting-group input[type="number"] {
    width: 80px;
    padding: 10px 12px;
    border: 1px solid var(--bd);
    border-radius: 6px;
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    font-size: 14px;
    outline: none;
    -moz-appearance: textfield;
    transition: border-color 0.2s, background-color 0.2s;
  }
  
  .setting-group input[type="number"]:focus {
    border-color: #344532;
    background: rgba(255, 255, 255, 0.15);
  }

  .setting-group input[type="number"]::-webkit-outer-spin-button,
  .setting-group input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .delete-all-btn {
    width: 100%;
    padding: 12px;
    background: #2a3628;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.2s;
  }

  .delete-all-btn:hover {
    background: #1f2a1d;
  }

  .modal-buttons .delete-confirm {
    background: #dc2626;
  }

  .modal-buttons .delete-confirm:hover {
    background: #b91c1c;
  }
</file>

</files>
