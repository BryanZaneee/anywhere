This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
src/
  app.ts
  index.html
  styles.css
.gitignore
CLAUDE.md
package.json
readme.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(open:*)",
      "Bash(grep:*)",
      "Bash(sed:*)",
      "Bash(npx tsc:*)",
      "Bash(npm install)",
      "Bash(rm:*)",
      "Bash(npm run build:*)",
      "Bash(npm install:*)",
      "Bash(npm run dev:*)",
      "Bash(ls:*)",
      "Bash(pkill:*)"
    ],
    "deny": []
  }
}
</file>

<file path="src/app.ts">
// Type definitions
interface NoteStyles {
  bold: boolean;
  italic: boolean;
  underline: boolean;
  strike: boolean;
  fontSize: string;
  fontFamily: string;
  align: 'left' | 'center' | 'right';
  listType: 'none' | 'bullet' | 'numbered';
}

interface NoteData {
  x: number;
  y: number;
  text: string;
  html: string;
  styles: NoteStyles;
}

interface AppDocument {
  id: string;
  title: string;
  notes: NoteData[];
  pinned: boolean;
  hasCustomTitle?: boolean;
}

interface NoteObject {
  el: HTMLDivElement;
  styles: NoteStyles;
}

interface AppSettings {
  headerIdleTimeout: number;
  headerCanHide: boolean;
}

interface KeyboardShortcut {
  action: string;
  mac: string;
  windows: string;
}

interface ShortcutSection {
  title: string;
  shortcuts: KeyboardShortcut[];
}

interface KeyboardShortcuts {
  [key: string]: ShortcutSection;
}

interface DocumentHistoryState {
  docId: string;
  notes: NoteData[];
}

type ThemeMode = 'light' | 'dark';
type Platform = 'mac' | 'windows';
type FontSize = '12px' | '14px' | '16px' | '18px' | '20px' | '24px' | '28px' | '32px' | '48px';
type FontFamily = 
  | "-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif"
  | "Georgia,'Times New Roman',serif"
  | "'Courier New',Consolas,monospace"
  | "Arial,Helvetica,sans-serif"
  | "'Times New Roman',Times,serif"
  | "Verdana,Geneva,sans-serif";

interface DocumentsStorage {
  [id: string]: AppDocument;
}

// Note: We'll use type assertions (note as any).__noteData for the custom property

// State management
let currentNote: NoteObject | null = null;
let currentDocId: string = '';
let documents: DocumentsStorage = {};
let hasTyped: boolean = false;
let selectedNotes: Set<HTMLDivElement> = new Set();
let isSelecting: boolean = false;
let selectBox: HTMLDivElement | null = null;
let startX: number = 0;
let startY: number = 0;
let isDraggingGroup: boolean = false;
let dragHandle: HTMLDivElement | null = null;
let justCompletedSelection: boolean = false;

// Header auto-hide system
let headerIdleTimer: number | null = null;
let headerIdleTimeout: number = 10000; // 10 seconds default
let headerCanHide: boolean = true;
let isToolbarHovered: boolean = false;
let shouldShowToolbarOnHover: boolean = false;

// Utility functions
function focusCurrentNoteIfSingle(): void {
  if (currentNote && selectedNotes.size <= 1) {
    currentNote.el.focus();
  }
}

function generateTitleFromText(text: string): string {
  if (!text || typeof text !== 'string') {
    return 'Untitled';
  }
  
  // Remove HTML tags and clean up text
  const cleanText = text
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .replace(/\s+/g, ' ')    // Normalize whitespace
    .trim();
  
  if (!cleanText) {
    return 'Untitled';
  }
  
  // Extract first few words, limit to 30 characters
  const words = cleanText.split(' ').filter(word => word.length > 0);
  let title = '';
  
  for (let i = 0; i < Math.min(5, words.length); i++) {
    const nextWord = words[i];
    if (title.length + nextWord.length + (i > 0 ? 1 : 0) <= 30) {
      title += (i > 0 ? ' ' : '') + nextWord;
    } else {
      break;
    }
  }
  
  return title || 'Untitled';
}

function updateUI(): void {
  updateStyles();
  updateToolbar();
}

function applyStylesAndUpdate(element: HTMLDivElement, styles: NoteStyles): void {
  applyStyles(element, styles);
  updateStyles();
}

function positionCursorInElement(element: HTMLElement): void {
  const range = document.createRange();
  range.selectNodeContents(element);
  range.collapse(false);
  const selection = window.getSelection();
  if (selection) {
    selection.removeAllRanges();
    selection.addRange(range);
  }
}

// Undo/Redo system
let documentHistory: DocumentHistoryState[] = [];
let historyIndex: number = -1;
const MAX_HISTORY: number = 50;

// DOM elements
const $: (id: string) => HTMLElement = (id: string) => {
  const element = document.getElementById(id);
  if (!element) {
    throw new Error(`Element with id "${id}" not found`);
  }
  return element;
};

const appToolbar = $('toolbar') as HTMLDivElement;
const logo = $('logo') as HTMLDivElement;
const canvas = $('canvas') as HTMLDivElement;
const sidebar = $('sidebar') as HTMLDivElement;
const notesList = $('notesList') as HTMLDivElement;
const searchInput = $('searchInput') as HTMLInputElement;
const themeText = $('themeText') as HTMLSpanElement;

// Create toolbar hover zone
const toolbarHoverZone = document.createElement('div');
toolbarHoverZone.id = 'toolbarHoverZone';
document.body.appendChild(toolbarHoverZone);

// Theme management
function loadTheme(): void {
  const isDark = localStorage.getItem('darkMode') === 'true';
  document.body.classList.toggle('dark', isDark);
  themeText.textContent = isDark ? 'Dark Mode' : 'Light Mode';
}

// Keyboard shortcuts data
const keyboardShortcuts: KeyboardShortcuts = {
  global: {
    title: "Global Shortcuts",
    shortcuts: [
      {
        action: "New Document",
        mac: "⌘ + N",
        windows: "Ctrl + N"
      },
      {
        action: "Save Document",
        mac: "⌘ + S", 
        windows: "Ctrl + S"
      },
      {
        action: "Undo",
        mac: "⌘ + Z",
        windows: "Ctrl + Z"
      },
      {
        action: "Redo",
        mac: "⌘ + Shift + Z",
        windows: "Ctrl + Shift + Z"
      },
      {
        action: "Select All Notes",
        mac: "⌘ + A",
        windows: "Ctrl + A"
      },
      {
        action: "Clear Selection",
        mac: "Escape",
        windows: "Escape"
      }
    ]
  },
  selection: {
    title: "Selection Shortcuts",
    shortcuts: [
      {
        action: "Copy Selected Notes",
        mac: "⌘ + C",
        windows: "Ctrl + C"
      },
      {
        action: "Paste Notes",
        mac: "⌘ + V",
        windows: "Ctrl + V"
      },
      {
        action: "Duplicate Selected Notes",
        mac: "⌘ + D",
        windows: "Ctrl + D"
      },
      {
        action: "Delete Selected Notes",
        mac: "Delete / Backspace",
        windows: "Delete / Backspace"
      },
      {
        action: "Move Selected Notes",
        mac: "Arrow Keys",
        windows: "Arrow Keys"
      },
      {
        action: "Move Selected Notes (10px)",
        mac: "Shift + Arrow Keys",
        windows: "Shift + Arrow Keys"
      },
      {
        action: "Increase Font Size",
        mac: "⌘ + =",
        windows: "Ctrl + ="
      },
      {
        action: "Decrease Font Size",
        mac: "⌘ + -",
        windows: "Ctrl + -"
      }
    ]
  },
  noteEditing: {
    title: "Note Editing",
    shortcuts: [
      {
        action: "Bold (within note)",
        mac: "⌘ + B",
        windows: "Ctrl + B"
      },
      {
        action: "Italic (within note)",
        mac: "⌘ + I",
        windows: "Ctrl + I"
      },
      {
        action: "Underline (within note)",
        mac: "⌘ + U",
        windows: "Ctrl + U"
      },
      {
        action: "Align Left (within note)",
        mac: "⌘ + L",
        windows: "Ctrl + L"
      },
      {
        action: "Align Center (within note)",
        mac: "⌘ + E",
        windows: "Ctrl + E"
      },
      {
        action: "Align Right (within note)",
        mac: "⌘ + R",
        windows: "Ctrl + R"
      }
    ]
  },
  formatting: {
    title: "Multi-Note Formatting",
    shortcuts: [
      {
        action: "Bold (selected notes)",
        mac: "⌘ + B",
        windows: "Ctrl + B"
      },
      {
        action: "Italic (selected notes)",
        mac: "⌘ + I",
        windows: "Ctrl + I"
      },
      {
        action: "Underline (selected notes)",
        mac: "⌘ + U",
        windows: "Ctrl + U"
      },
      {
        action: "Strikethrough",
        mac: "⌘ + Shift + X",
        windows: "Ctrl + Shift + X"
      },
      {
        action: "Align Left (selected notes)",
        mac: "⌘ + L",
        windows: "Ctrl + L"
      },
      {
        action: "Align Center (selected notes)",
        mac: "⌘ + E",
        windows: "Ctrl + E"
      },
      {
        action: "Align Right (selected notes)",
        mac: "⌘ + R",
        windows: "Ctrl + R"
      },
      {
        action: "Bullet List",
        mac: "⌘ + Shift + 8",
        windows: "Ctrl + Shift + 8"
      },
      {
        action: "Numbered List",
        mac: "⌘ + Shift + 7",
        windows: "Ctrl + Shift + 7"
      }
    ]
  }
};

// Generate shortcuts HTML for the specified platform
function generateShortcutsHTML(platform: Platform): string {
  let html = '';
  
  Object.entries(keyboardShortcuts).forEach(([category, data]) => {
    html += `
      <div class="shortcuts-section">
        <h4>${data.title}</h4>
        <div class="shortcuts-list">
    `;
    
    data.shortcuts.forEach(shortcut => {
      const key = platform === 'mac' ? shortcut.mac : shortcut.windows;
      html += `
        <div class="shortcut-item">
          <span class="shortcut-action">${shortcut.action}</span>
          <span class="shortcut-key">${key}</span>
        </div>
      `;
    });
    
    html += `
        </div>
      </div>
    `;
  });
  
  return html;
}

// Settings management
function loadSettings(): void {
  const saved = localStorage.getItem('anywhereSettings');
  if (saved) {
    const settings: AppSettings = JSON.parse(saved);
    headerIdleTimeout = settings.headerIdleTimeout || 10000;
    headerCanHide = settings.headerCanHide !== false;
  }
}

function saveSettings(): void {
  const settings: AppSettings = {
    headerIdleTimeout,
    headerCanHide
  };
  localStorage.setItem('anywhereSettings', JSON.stringify(settings));
}

// Helper function to show toolbar properly
function showToolbar(): void {
  appToolbar.classList.add('show');
  shouldShowToolbarOnHover = true; // Enable hover zone when toolbar is shown
  resetHeaderTimer();
}

// Header auto-hide system
function resetHeaderTimer(): void {
  if (!headerCanHide) return;
  
  // Clear existing timer
  if (headerIdleTimer) {
    clearTimeout(headerIdleTimer);
  }
  
  // Set new timer to hide toolbar
  headerIdleTimer = window.setTimeout(() => {
    if (headerCanHide && appToolbar.classList.contains('show') && !isToolbarHovered) {
      appToolbar.classList.remove('show');
      shouldShowToolbarOnHover = true; // Keep hover zone active after auto-hide
    }
  }, headerIdleTimeout);
}

function initHeaderAutoHide(): void {
  // Add event listeners for user activity
  const events = ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart'];
  events.forEach(event => {
    document.addEventListener(event, resetHeaderTimer, true);
  });
  
  // Add hover detection for toolbar
  appToolbar.addEventListener('mouseenter', () => {
    isToolbarHovered = true;
  });
  
  appToolbar.addEventListener('mouseleave', () => {
    isToolbarHovered = false;
    // Restart timer when mouse leaves toolbar
    resetHeaderTimer();
  });
  
  // Add hover zone detection to show toolbar when cursor is at top
  toolbarHoverZone.addEventListener('mouseenter', () => {
    // Only show toolbar if hover zone is active and there's content that could use formatting
    if (shouldShowToolbarOnHover && (hasTyped || selectedNotes.size > 0 || currentNote)) {
      showToolbar();
    }
  });
  
  // Start the timer
  resetHeaderTimer();
}

// Document management
function loadDocuments(): void {
  const saved = localStorage.getItem('anywhereDocuments');
  if (saved) documents = JSON.parse(saved);
  
  // Migrate existing documents to include hasCustomTitle flag
  Object.values(documents).forEach(doc => {
    if (doc.hasCustomTitle === undefined) {
      // If title starts with "Note #", it was auto-generated, otherwise it's custom
      doc.hasCustomTitle = !doc.title.startsWith('Note #');
    }
  });
  
  if (!Object.keys(documents).length) {
    createNewDocument();
  } else {
    currentDocId = Object.keys(documents)[0];
    loadDocument(currentDocId);
  }
  updateNotesList();
}

function saveDocuments(): void {
  localStorage.setItem('anywhereDocuments', JSON.stringify(documents));
}

function createNewDocument(): void {
  const id = Date.now().toString();
  documents[id] = { id, title: 'Untitled', notes: [], pinned: false, hasCustomTitle: false };
  currentDocId = id;
  clearCanvas();
  saveDocuments();
  updateNotesList();
}

function clearCanvas(): void {
  canvas.querySelectorAll('.note').forEach(n => n.remove());
  logo.classList.remove('slide-away', 'hidden');
  hasTyped = false;
  selectedNotes.clear();
}

function loadDocument(id: string): void {
  clearCanvas();
  const doc = documents[id];
  if (!doc) return;
  
  currentDocId = id;
  if (doc.notes.length) {
    logo.classList.add('slide-away');
    setTimeout(() => logo.classList.add('hidden'), 500);
    hasTyped = true;
  }
  
  doc.notes.forEach(noteData => {
    const note = document.createElement('div');
    note.className = 'note';
    note.contentEditable = 'true';
    note.style.left = noteData.x + 'px';
    note.style.top = noteData.y + 'px';
    note.style.textAlign = noteData.styles.align || 'left';
    note.innerHTML = noteData.html || noteData.text || '';
    
    const noteObj: NoteObject = {
      el: note,
      styles: { ...noteData.styles, align: noteData.styles.align || 'left' }
    };
    
    applyStyles(note, noteData.styles);
    canvas.appendChild(note);
    setupNote(note, noteObj);
  });
  
  updateNotesList();
}

function saveCurrentDocument(): void {
  if (!currentDocId) return;
  
  const notes: NoteData[] = Array.from(canvas.querySelectorAll<HTMLDivElement>('.note')).map(note => {
    const noteData = (note as any).__noteData;
    return {
      x: parseInt(note.style.left),
      y: parseInt(note.style.top),
      text: note.textContent || '',
      html: note.innerHTML || '',
      styles: noteData ? noteData.styles : {
        bold: false,
        italic: false,
        underline: false,
        strike: false,
        fontSize: '16px',
        fontFamily: '-apple-system,BlinkMacSystemFont,\'Segoe UI\',sans-serif',
        align: 'left',
        listType: 'none'
      }
    };
  });
  
  documents[currentDocId].notes = notes;
  
  // Auto-generate title from first note if document hasn't been manually titled
  const currentDoc = documents[currentDocId];
  if (!currentDoc.hasCustomTitle && notes.length > 0) {
    const firstNoteText = notes[0].text;
    if (firstNoteText && firstNoteText.trim()) {
      const newTitle = generateTitleFromText(firstNoteText);
      if (newTitle !== 'Untitled') {
        currentDoc.title = newTitle;
        updateNotesList(); // Update the sidebar display immediately
      }
    }
  }
  
  saveDocuments();
}

// Undo/Redo system functions
function saveToHistory(): void {
  if (!currentDocId) return;
  
  // Create a deep copy of the current document state
  const currentState: DocumentHistoryState = {
    docId: currentDocId,
    notes: JSON.parse(JSON.stringify(documents[currentDocId].notes))
  };
  
  // Remove any history after current index (when undoing then making new changes)
  if (historyIndex < documentHistory.length - 1) {
    documentHistory = documentHistory.slice(0, historyIndex + 1);
  }
  
  // Add new state
  documentHistory.push(currentState);
  
  // Keep history within limits
  if (documentHistory.length > MAX_HISTORY) {
    documentHistory.shift();
  } else {
    historyIndex++;
  }
}

function undo(): boolean {
  if (historyIndex <= 0) return false;
  
  historyIndex--;
  const state = documentHistory[historyIndex];
  
  if (state.docId === currentDocId) {
    // Restore document state
    documents[currentDocId].notes = JSON.parse(JSON.stringify(state.notes));
    loadDocument(currentDocId);
    return true;
  }
  return false;
}

function redo(): boolean {
  if (historyIndex >= documentHistory.length - 1) return false;
  
  historyIndex++;
  const state = documentHistory[historyIndex];
  
  if (state.docId === currentDocId) {
    // Restore document state
    documents[currentDocId].notes = JSON.parse(JSON.stringify(state.notes));
    loadDocument(currentDocId);
    return true;
  }
  return false;
}

// Note list UI
function updateNotesList(): void {
  notesList.innerHTML = '';
  const docs = Object.values(documents)
    .filter(doc => doc.title.toLowerCase().includes(searchInput.value.toLowerCase()));
  
  const pinned = docs.filter(d => d.pinned);
  const unpinned = docs.filter(d => !d.pinned);
  
  if (pinned.length) {
    const section = document.createElement('div');
    section.className = 'pinned-section';
    const title = document.createElement('div');
    title.className = 'pinned-title';
    title.textContent = 'Pinned';
    section.appendChild(title);
    pinned.forEach(doc => section.appendChild(createNoteItem(doc)));
    notesList.appendChild(section);
  }
  
  unpinned.forEach(doc => notesList.appendChild(createNoteItem(doc)));
}

function createNoteItem(doc: AppDocument): HTMLDivElement {
  const item = document.createElement('div');
  item.className = 'note-item';
  if (doc.id === currentDocId) item.classList.add('active');
  
  const textDiv = document.createElement('div');
  textDiv.className = 'note-text';
  const text = document.createElement('span');
  text.textContent = doc.title;
  text.ondblclick = e => {
    e.stopPropagation();
    startInlineEdit();
  };
  textDiv.appendChild(text);
  item.appendChild(textDiv);
  
  // Make entire item clickable
  item.onclick = e => {
    // Don't trigger if clicking on action buttons
    if ((e.target as HTMLElement).closest('.note-actions')) return;
    loadDocument(doc.id);
  };
  
  const actions = document.createElement('div');
  actions.className = 'note-actions';
  
  // Pin button
  const pinBtn = document.createElement('button');
  pinBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="${doc.pinned ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
    <path d="M12 2L9 9H2l6 4-2 7 6-5 6 5-2-7 6-4h-7z"/>
  </svg>`;
  pinBtn.onclick = e => {
    e.stopPropagation();
    doc.pinned = !doc.pinned;
    saveDocuments();
    updateNotesList();
  };
  
  // Edit button
  const editBtn = document.createElement('button');
  editBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
  </svg>`;
  editBtn.onclick = e => {
    e.stopPropagation();
    startInlineEdit();
  };
  
  // Inline edit function
  function startInlineEdit(): void {
    const input = document.createElement('input');
    input.value = doc.title;
    input.onblur = () => {
      if (input.value.trim()) {
        doc.title = input.value.trim();
        doc.hasCustomTitle = true; // Mark as manually titled
        saveDocuments();
      }
      updateNotesList();
    };
    input.onkeydown = e => {
      if (e.key === 'Enter') {
        input.blur();
      } else if (e.key === 'Escape') {
        updateNotesList();
      }
    };
    textDiv.innerHTML = '';
    textDiv.appendChild(input);
    input.focus();
    input.select();
  }
  
  // Delete button
  const delBtn = document.createElement('button');
  delBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <polyline points="3 6 5 6 21 6"/>
    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
  </svg>`;
  delBtn.onclick = e => {
    e.stopPropagation();
    showDeleteModal(doc);
  };
  
  actions.appendChild(pinBtn);
  actions.appendChild(editBtn);
  actions.appendChild(delBtn);
  item.appendChild(actions);
  
  return item;
}

function showDeleteModal(doc: AppDocument): void {
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-content">
      <h3>Delete this note?</h3>
      <p>This action cannot be undone.</p>
      <div class="modal-buttons">
        <button class="cancel">Cancel</button>
        <button class="confirm">OK</button>
      </div>
    </div>
  `;
  
  modal.querySelector<HTMLButtonElement>('.cancel')!.onclick = () => modal.remove();
  modal.querySelector<HTMLButtonElement>('.confirm')!.onclick = () => {
    delete documents[doc.id];
    if (doc.id === currentDocId) {
      const remaining = Object.keys(documents);
      if (remaining.length) {
        loadDocument(remaining[0]);
      } else {
        createNewDocument();
      }
    }
    saveDocuments();
    updateNotesList();
    modal.remove();
  };
  
  document.body.appendChild(modal);
}

function showSettingsModal(): void {
  // Detect user's platform for default preference
  const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
  const defaultPlatform: Platform = isMac ? 'mac' : 'windows';
  const preferredPlatform: Platform = (localStorage.getItem('preferredShortcutPlatform') as Platform) || defaultPlatform;
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-content settings-modal tabbed-modal">
      <button class="modal-close">×</button>
      
      <div class="settings-body">
        <div class="settings-sidebar">
          <div class="settings-tab active" data-tab="options" title="Options">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
            <span>Options</span>
          </div>
          <div class="settings-tab" data-tab="shortcuts" title="Keyboard Shortcuts">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
              <line x1="8" y1="21" x2="16" y2="21"></line>
              <line x1="12" y1="17" x2="12" y2="21"></line>
            </svg>
            <span>Shortcuts</span>
          </div>
        </div>
        
        <div class="settings-content">
          <div class="settings-panel active" id="options-panel">
            <div class="settings-header">
              <h3>General</h3>
              <p class="tab-description">Application settings and preferences</p>
            </div>
            <div class="setting-group">
              <label for="idleTimeInput">Toolbar auto-hide delay (seconds):</label>
              <input type="number" id="idleTimeInput" min="1" max="99" value="${headerIdleTimeout / 1000}">
            </div>
            
            <div class="setting-group">
              <label>
                <input type="checkbox" id="headerToggle" ${headerCanHide ? 'checked' : ''}>
                Allow toolbar to auto-hide
              </label>
            </div>
            
            <div class="setting-group">
              <button class="delete-all-btn" id="deleteAllNotes">Delete All Notes</button>
            </div>
          </div>
          
          <div class="settings-panel" id="shortcuts-panel">
            <div class="settings-header">
              <h3>Shortcuts</h3>
              <p class="tab-description">Keyboard shortcuts and hotkeys</p>
            </div>
            <div class="platform-toggle">
              <span class="toggle-label">Show shortcuts for:</span>
              <div class="toggle-switch">
                <input type="radio" id="platform-mac" name="platform" value="mac" ${preferredPlatform === 'mac' ? 'checked' : ''}>
                <label for="platform-mac">Mac</label>
                <input type="radio" id="platform-windows" name="platform" value="windows" ${preferredPlatform === 'windows' ? 'checked' : ''}>
                <label for="platform-windows">Windows</label>
              </div>
            </div>
            
            <div class="shortcuts-content" id="shortcuts-content">
              ${generateShortcutsHTML(preferredPlatform)}
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
  
  const idleTimeInput = modal.querySelector<HTMLInputElement>('#idleTimeInput')!;
  const headerToggle = modal.querySelector<HTMLInputElement>('#headerToggle')!;
  
  // Close button handler
  modal.querySelector<HTMLButtonElement>('.modal-close')!.onclick = () => modal.remove();
  
  // Tab switching functionality
  const tabs = modal.querySelectorAll('.settings-tab');
  const panels = modal.querySelectorAll('.settings-panel');
  
  tabs.forEach(tab => {
    (tab as HTMLElement).onclick = () => {
      // Remove active class from all tabs and panels
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(p => p.classList.remove('active'));
      
      // Add active class to clicked tab and corresponding panel
      tab.classList.add('active');
      const tabElement = tab as HTMLElement;
      const targetPanel = modal.querySelector(`#${tabElement.dataset.tab}-panel`);
      if (targetPanel) {
        targetPanel.classList.add('active');
      }
    };
  });
  
  // Platform toggle functionality
  const platformRadios = modal.querySelectorAll<HTMLInputElement>('input[name="platform"]');
  const shortcutsContent = modal.querySelector<HTMLDivElement>('#shortcuts-content')!;
  
  platformRadios.forEach(radio => {
    radio.onchange = () => {
      if (radio.checked) {
        shortcutsContent.innerHTML = generateShortcutsHTML(radio.value as Platform);
        localStorage.setItem('preferredShortcutPlatform', radio.value);
      }
    };
  });
  
  // Auto-save functionality
  function autoSaveSettings(): void {
    headerIdleTimeout = parseInt(idleTimeInput.value) * 1000;
    headerCanHide = headerToggle.checked;
    saveSettings();
    
    // Reset header visibility based on new settings
    if (headerCanHide) {
      resetHeaderTimer();
    } else {
      if (headerIdleTimer) {
        clearTimeout(headerIdleTimer);
      }
    }
  }
  
  // Validate number input and auto-save
  idleTimeInput.oninput = () => {
    let value = parseInt(idleTimeInput.value);
    if (isNaN(value) || value < 1) {
      idleTimeInput.value = '1';
    } else if (value > 99) {
      idleTimeInput.value = '99';
    }
    autoSaveSettings();
  };
  
  // Auto-save when checkbox changes
  headerToggle.onchange = autoSaveSettings;
  
  modal.querySelector<HTMLButtonElement>('#deleteAllNotes')!.onclick = () => {
    modal.remove();
    showDeleteAllModal();
  };
  
  document.body.appendChild(modal);
}

function showDeleteAllModal(): void {
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-content">
      <h3>Delete All Notes?</h3>
      <p><strong>This will permanently delete all notes in the current document.</strong></p>
      <p>This action cannot be undone.</p>
      <div class="modal-buttons">
        <button class="cancel">Cancel</button>
        <button class="confirm delete-confirm">Delete All</button>
      </div>
    </div>
  `;
  
  modal.querySelector<HTMLButtonElement>('.cancel')!.onclick = () => modal.remove();
  modal.querySelector<HTMLButtonElement>('.confirm')!.onclick = () => {
    // Clear all notes from current document
    if (currentDocId && documents[currentDocId]) {
      documents[currentDocId].notes = [];
      clearCanvas();
      saveDocuments();
    }
    modal.remove();
  };
  
  document.body.appendChild(modal);
}

// Note setup and interactions
function setupNote(note: HTMLDivElement, noteObj: NoteObject): void {
  (note as any).__noteData = noteObj;
  
  note.addEventListener('mousedown', e => {
    // Use position-based detection to determine if click is over actual text content
    const hasExistingSelection = window.getSelection()?.toString();
    
    // Check if the click position is over text content using Range API
    let isOverTextContent = false;
    try {
      const range = document.caretRangeFromPoint(e.clientX, e.clientY);
      if (range && range.startContainer) {
        // If we can get a valid range and it's within this note, it's over text content
        isOverTextContent = note.contains(range.startContainer) && 
                           (range.startContainer.nodeType === Node.TEXT_NODE || 
                            range.startContainer !== note);
      }
    } catch (err) {
      // Fallback: if Range API fails, allow text selection by default
      isOverTextContent = e.target !== note;
    }
    
    // If clicking over text content, allow natural text selection
    if (isOverTextContent && !hasExistingSelection) {
      return; // Let browser handle text selection naturally
    }
    
    // Only handle note selection when clicking on empty areas
    if (e.target === note && !hasExistingSelection && !isOverTextContent) {
      if (!e.shiftKey) selectedNotes.clear();
      selectedNotes.add(note);
      updateSelection();
      e.preventDefault();
    }
  });
  
  note.addEventListener('focus', () => {
    currentNote = noteObj;
    showToolbar();
    updateToolbar();
  });
  
  note.addEventListener('blur', () => {
    if (!note.innerHTML.trim()) note.remove();
    saveCurrentDocument();
  });
  
  note.addEventListener('input', () => {
    if (!hasTyped && note.textContent?.length) {
      hasTyped = true;
      logo.classList.add('slide-away');
      setTimeout(() => logo.classList.add('hidden'), 500);
    }
    saveCurrentDocument();
  });
  
  note.addEventListener('mouseup', () => {
    // Show toolbar when text is selected
    if (window.getSelection()?.toString()) {
      currentNote = noteObj;
      showToolbar();
      updateToolbar();
    }
  });
  
  // Handle text selection changes
  note.addEventListener('selectstart', () => {
    // Allow text selection to start naturally
    currentNote = noteObj;
  });
  
  // Note keyboard shortcuts
  note.addEventListener('keydown', e => {
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
    
    if (ctrlKey) {
      switch (e.key.toLowerCase()) {
        case 'b':
          e.preventDefault();
          document.execCommand('bold');
          break;
        case 'i':
          e.preventDefault();
          document.execCommand('italic');
          break;
        case 'u':
          e.preventDefault();
          document.execCommand('underline');
          break;
      }
    }
    
    // List shortcuts with Ctrl+Shift
    if (ctrlKey && e.shiftKey) {
      switch (e.key) {
        case '*':
        case '8':
          e.preventDefault();
          toggleBulletList();
          break;
        case '&':
        case '7':
          e.preventDefault();
          toggleNumberedList();
          break;
      }
    }
  });
}

// Selection management
function updateSelection(): void {
  canvas.querySelectorAll('.note').forEach(n => {
    n.classList.toggle('selected', selectedNotes.has(n as HTMLDivElement));
  });
  
  // Remove old handle
  const oldHandle = canvas.querySelector('.selection-handle');
  if (oldHandle) oldHandle.remove();
  
  if (selectedNotes.size > 1) {
    // Show handle for group dragging
    let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
    selectedNotes.forEach(note => {
      const x = parseInt(note.style.left);
      const y = parseInt(note.style.top);
      const w = note.offsetWidth;
      const h = note.offsetHeight;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + w);
      maxY = Math.max(maxY, y + h);
    });
    
    dragHandle = document.createElement('div');
    dragHandle.className = 'selection-handle';
    dragHandle.style.left = (maxX - 6) + 'px';
    dragHandle.style.top = (maxY - 6) + 'px';
    canvas.appendChild(dragHandle);
    
    dragHandle.onmousedown = e => {
      e.stopPropagation();
      isDraggingGroup = true;
      startX = e.clientX;
      startY = e.clientY;
    };
    
    showToolbar();
    updateToolbar();
  } else if (selectedNotes.size === 1) {
    const note = Array.from(selectedNotes)[0];
    currentNote = (note as any).__noteData!;
    showToolbar();
    updateToolbar();
  } else {
    appToolbar.classList.remove('show');
    shouldShowToolbarOnHover = false; // Disable hover zone when no selection
  }
}

// Styling functions
function applyStyles(el: HTMLDivElement, styles: NoteStyles): void {
  el.style.fontWeight = styles.bold ? 'bold' : 'normal';
  el.style.fontStyle = styles.italic ? 'italic' : 'normal';
  el.style.textDecoration = 
    (styles.underline ? 'underline ' : '') + (styles.strike ? 'line-through' : '');
  el.style.fontSize = styles.fontSize;
  el.style.fontFamily = styles.fontFamily;
  el.style.textAlign = styles.align || 'left';
  
  // Handle list formatting
  if (styles.listType && styles.listType !== 'none') {
    const text = el.textContent || el.innerHTML;
    if (text && !el.querySelector('ul, ol')) {
      // Convert text to list if not already formatted
      const lines = text.split('\n').filter(line => line.trim());
      if (lines.length > 0) {
        const listTag = styles.listType === 'bullet' ? 'ul' : 'ol';
        const listItems = lines.map(line => `<li>${line.trim()}</li>`).join('');
        el.innerHTML = `<${listTag}>${listItems}</${listTag}>`;
      }
    }
  } else if (styles.listType === 'none') {
    // Convert list back to plain text if needed
    const lists = el.querySelectorAll('ul, ol');
    lists.forEach(list => {
      const text = Array.from(list.querySelectorAll('li')).map(li => li.textContent).join('\n');
      list.outerHTML = text;
    });
  }
}

function updateStyles(): void {
  if (selectedNotes.size > 1) {
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
  } else if (currentNote) {
    applyStyles(currentNote.el, currentNote.styles);
  }
  saveCurrentDocument();
}

function toggleBulletList(): void {
  const sel = window.getSelection();
  if (sel?.toString() && sel.rangeCount) {
    // Text is selected - apply to selection
    document.execCommand('insertUnorderedList');
    saveCurrentDocument();
  } else if (selectedNotes.size > 1) {
    // Multiple notes selected
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        const currentListType = (note as any).__noteData.styles.listType;
        const isTogglingOn = currentListType !== 'bullet';
        (note as any).__noteData.styles.listType = isTogglingOn ? 'bullet' : 'none';
        
        // If note is empty and we're turning on list, insert empty list item
        if (isTogglingOn && !note.textContent?.trim()) {
          note.innerHTML = '<ul><li></li></ul>';
          // Position cursor in the list item
          const li = note.querySelector('li');
          if (li) {
            li.focus();
            positionCursorInElement(li);
          }
        } else {
          applyStyles(note, (note as any).__noteData.styles);
        }
      }
    });
    updateStyles();
  } else if (currentNote) {
    // Single note, no selection
    const currentListType = currentNote.styles.listType;
    const isTogglingOn = currentListType !== 'bullet';
    currentNote.styles.listType = isTogglingOn ? 'bullet' : 'none';
    
    // If note is empty and we're turning on list, insert empty list item
    if (isTogglingOn && !currentNote.el.textContent?.trim()) {
      currentNote.el.innerHTML = '<ul><li></li></ul>';
      // Position cursor in the list item
      const li = currentNote.el.querySelector('li');
      if (li) {
        li.focus();
        positionCursorInElement(li);
      }
    } else {
      applyStyles(currentNote.el, currentNote.styles);
    }
    updateStyles();
  }
  updateToolbar();
  focusCurrentNoteIfSingle();
}

function toggleNumberedList(): void {
  const sel = window.getSelection();
  if (sel?.toString() && sel.rangeCount) {
    // Text is selected - apply to selection
    document.execCommand('insertOrderedList');
    saveCurrentDocument();
  } else if (selectedNotes.size > 1) {
    // Multiple notes selected
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        const currentListType = (note as any).__noteData.styles.listType;
        const isTogglingOn = currentListType !== 'numbered';
        (note as any).__noteData.styles.listType = isTogglingOn ? 'numbered' : 'none';
        
        // If note is empty and we're turning on list, insert empty list item
        if (isTogglingOn && !note.textContent?.trim()) {
          note.innerHTML = '<ol><li></li></ol>';
          // Position cursor in the list item
          const li = note.querySelector('li');
          if (li) {
            li.focus();
            positionCursorInElement(li);
          }
        } else {
          applyStyles(note, (note as any).__noteData.styles);
        }
      }
    });
    updateStyles();
  } else if (currentNote) {
    // Single note, no selection
    const currentListType = currentNote.styles.listType;
    const isTogglingOn = currentListType !== 'numbered';
    currentNote.styles.listType = isTogglingOn ? 'numbered' : 'none';
    
    // If note is empty and we're turning on list, insert empty list item
    if (isTogglingOn && !currentNote.el.textContent?.trim()) {
      currentNote.el.innerHTML = '<ol><li></li></ol>';
      // Position cursor in the list item
      const li = currentNote.el.querySelector('li');
      if (li) {
        li.focus();
        positionCursorInElement(li);
      }
    } else {
      applyStyles(currentNote.el, currentNote.styles);
    }
    updateStyles();
  }
  updateToolbar();
  focusCurrentNoteIfSingle();
}

function updateToolbar(): void {
  if (selectedNotes.size > 1) {
    const firstNote = (Array.from(selectedNotes)[0] as any).__noteData;
    if (firstNote) {
      const s = firstNote.styles;
      // Show formatting buttons for multi-selection too
      ($('bold') as HTMLButtonElement).classList.toggle('active', s.bold);
      ($('italic') as HTMLButtonElement).classList.toggle('active', s.italic);
      ($('underline') as HTMLButtonElement).classList.toggle('active', s.underline);
      ($('strike') as HTMLButtonElement).classList.toggle('active', s.strike);
      ($('alignLeft') as HTMLButtonElement).classList.toggle('active', s.align === 'left');
      ($('alignCenter') as HTMLButtonElement).classList.toggle('active', s.align === 'center');
      ($('alignRight') as HTMLButtonElement).classList.toggle('active', s.align === 'right');
      ($('bulletList') as HTMLButtonElement).classList.toggle('active', s.listType === 'bullet');
      ($('numberedList') as HTMLButtonElement).classList.toggle('active', s.listType === 'numbered');
      ($('fontSize') as HTMLSelectElement).value = s.fontSize;
      ($('fontFamily') as HTMLSelectElement).value = s.fontFamily;
    }
  } else if (currentNote) {
    const s = currentNote.styles;
    ($('bold') as HTMLButtonElement).classList.toggle('active', s.bold);
    ($('italic') as HTMLButtonElement).classList.toggle('active', s.italic);
    ($('underline') as HTMLButtonElement).classList.toggle('active', s.underline);
    ($('strike') as HTMLButtonElement).classList.toggle('active', s.strike);
    ($('alignLeft') as HTMLButtonElement).classList.toggle('active', s.align === 'left');
    ($('alignCenter') as HTMLButtonElement).classList.toggle('active', s.align === 'center');
    ($('alignRight') as HTMLButtonElement).classList.toggle('active', s.align === 'right');
    ($('bulletList') as HTMLButtonElement).classList.toggle('active', s.listType === 'bullet');
    ($('numberedList') as HTMLButtonElement).classList.toggle('active', s.listType === 'numbered');
    ($('fontSize') as HTMLSelectElement).value = s.fontSize;
    ($('fontFamily') as HTMLSelectElement).value = s.fontFamily;
  }
}

// Canvas interactions
canvas.addEventListener('mousedown', e => {
  if (!(e.target as HTMLElement).classList.contains('note') && e.target !== logo && e.target !== dragHandle) {
    isSelecting = true;
    startX = e.clientX;
    startY = e.clientY;
    selectBox = document.createElement('div');
    selectBox.className = 'select-box';
    canvas.appendChild(selectBox);
    if (!e.shiftKey) {
      selectedNotes.clear();
      // Don't update selection immediately - wait for mousemove to add notes
      // This prevents toolbar from hiding during drag selection
    }
  }
});

canvas.addEventListener('mousemove', e => {
  if (isSelecting && selectBox) {
    const x = Math.min(e.clientX, startX);
    const y = Math.min(e.clientY, startY);
    const w = Math.abs(e.clientX - startX);
    const h = Math.abs(e.clientY - startY);
    selectBox.style.left = (x - canvas.offsetLeft) + 'px';
    selectBox.style.top = y + 'px';
    selectBox.style.width = w + 'px';
    selectBox.style.height = h + 'px';
    
    const rect = { left: x, top: y, right: x + w, bottom: y + h };
    let selectionChanged = false;
    const previousSize = selectedNotes.size;
    
    canvas.querySelectorAll<HTMLDivElement>('.note').forEach(note => {
      const nr = note.getBoundingClientRect();
      const shouldBeSelected = nr.left < rect.right && nr.right > rect.left && 
                              nr.top < rect.bottom && nr.bottom > rect.top;
      
      if (shouldBeSelected && !selectedNotes.has(note)) {
        selectedNotes.add(note);
        selectionChanged = true;
      } else if (!shouldBeSelected && !e.shiftKey && selectedNotes.has(note)) {
        selectedNotes.delete(note);
        selectionChanged = true;
      }
    });
    
    // Only update selection if it actually changed
    if (selectionChanged || selectedNotes.size !== previousSize) {
      updateSelection();
    }
  }
});

canvas.addEventListener('mouseup', e => {
  if (isSelecting) {
    isSelecting = false;
    if (selectBox) {
      selectBox.remove();
      selectBox = null;
    }
    // Ensure final selection state is updated
    updateSelection();
    
    // Set flag if we actually selected notes during the drag
    if (selectedNotes.size > 0) {
      justCompletedSelection = true;
      // Clear flag after a short delay to allow click event to check it
      setTimeout(() => { justCompletedSelection = false; }, 50);
    }
  }
});

canvas.addEventListener('click', e => {
  if (e.target === canvas || e.target === logo) {
    // If we just completed a selection, don't clear it or create a new note
    if (justCompletedSelection) {
      return;
    }
    
    // Clear selection if clicking on canvas (unless shift-clicking)
    if (!isSelecting && !e.shiftKey) {
      selectedNotes.clear();
      updateSelection();
    }
    
    // Create new note if clicking on canvas (not logo)
    if (e.target !== logo) {
      // Save state before creating new note
      saveToHistory();
      
      const note = document.createElement('div');
      note.className = 'note';
      note.contentEditable = 'true';
      note.style.left = (e.clientX - canvas.offsetLeft) + 'px';
      note.style.top = e.clientY + 'px';
      
      const noteObj: NoteObject = {
        el: note,
        styles: {
          bold: false,
          italic: false,
          underline: false,
          strike: false,
          fontSize: '16px',
          fontFamily: '-apple-system,BlinkMacSystemFont,\'Segoe UI\',sans-serif',
          align: 'left',
          listType: 'none'
        }
      };
      
      canvas.appendChild(note);
      setupNote(note, noteObj);
      note.focus();
    }
  }
});

// Toolbar interactions
document.addEventListener('click', e => {
  const target = e.target as HTMLElement;
  if (!appToolbar.contains(target) && 
      !target.classList.contains('note') &&
      !(document.activeElement as HTMLElement)?.classList.contains('note') &&
      selectedNotes.size === 0) {
    appToolbar.classList.remove('show');
    shouldShowToolbarOnHover = false; // Disable hover zone when clicking elsewhere
  }
});

document.addEventListener('mousemove', e => {
  if (isDraggingGroup) {
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    selectedNotes.forEach(note => {
      const x = parseInt(note.style.left);
      const y = parseInt(note.style.top);
      note.style.left = (x + dx) + 'px';
      note.style.top = (y + dy) + 'px';
    });
    if (dragHandle) {
      const hx = parseInt(dragHandle.style.left);
      const hy = parseInt(dragHandle.style.top);
      dragHandle.style.left = (hx + dx) + 'px';
      dragHandle.style.top = (hy + dy) + 'px';
    }
    startX = e.clientX;
    startY = e.clientY;
  }
});

document.addEventListener('mouseup', () => {
  if (isDraggingGroup) {
    isDraggingGroup = false;
    saveCurrentDocument();
  }
});

// Toolbar buttons
['bold', 'italic', 'underline', 'strike'].forEach(id => {
  $(id).onclick = () => {
    const sel = window.getSelection();
    if (sel?.toString() && sel.rangeCount) {
      // Text is selected - apply to selection
      if (id === 'strike') {
        document.execCommand('strikethrough');
      } else {
        document.execCommand(id);
      }
      saveCurrentDocument();
    } else if (selectedNotes.size > 1) {
      // Multiple notes selected
      selectedNotes.forEach(note => {
        if ((note as any).__noteData) {
          ((note as any).__noteData.styles as any)[id] = !((note as any).__noteData.styles as any)[id];
          applyStyles(note, (note as any).__noteData.styles);
        }
      });
      updateStyles();
    } else if (currentNote) {
      // Single note, no selection
      (currentNote.styles as any)[id] = !(currentNote.styles as any)[id];
      applyStylesAndUpdate(currentNote.el, currentNote.styles);
    }
    updateToolbar();
    focusCurrentNoteIfSingle();
  };
});

['alignLeft', 'alignCenter', 'alignRight'].forEach(align => {
  $(align).onclick = () => {
    const alignValue = align.replace('align', '').toLowerCase() as 'left' | 'center' | 'right';
    if (selectedNotes.size > 1) {
      selectedNotes.forEach(note => {
        if ((note as any).__noteData) {
          (note as any).__noteData.styles.align = alignValue;
          applyStyles(note, (note as any).__noteData.styles);
        }
      });
    } else if (currentNote) {
      currentNote.styles.align = alignValue;
      applyStyles(currentNote.el, currentNote.styles);
    }
    updateStyles();
    updateToolbar();
    focusCurrentNoteIfSingle();
  };
});

// List buttons
$('bulletList').onclick = toggleBulletList;
$('numberedList').onclick = toggleNumberedList;

($('fontSize') as HTMLSelectElement).onchange = () => {
  const size = ($('fontSize') as HTMLSelectElement).value as FontSize;
  const sel = window.getSelection();
  
  if (sel?.toString() && sel.rangeCount) {
    // Apply to selected text
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    span.style.fontSize = size;
    try {
      range.surroundContents(span);
    } catch (e) {
      document.execCommand('fontSize', false, '7');
      const fontElements = currentNote?.el.getElementsByTagName('font');
      if (fontElements) {
        for (let font of fontElements) {
          if ((font as any).size === '7') {
            font.removeAttribute('size');
            font.style.fontSize = size;
          }
        }
      }
    }
    saveCurrentDocument();
  } else if (selectedNotes.size > 1) {
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        (note as any).__noteData.styles.fontSize = size;
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    updateStyles();
  } else if (currentNote) {
    currentNote.styles.fontSize = size;
    applyStylesAndUpdate(currentNote.el, currentNote.styles);
  }
  focusCurrentNoteIfSingle();
};

($('fontFamily') as HTMLSelectElement).onchange = () => {
  const font = ($('fontFamily') as HTMLSelectElement).value as FontFamily;
  const sel = window.getSelection();
  
  if (sel?.toString() && sel.rangeCount) {
    // Apply to selected text
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    span.style.fontFamily = font;
    try {
      range.surroundContents(span);
    } catch (e) {
      document.execCommand('fontName', false, font);
    }
    saveCurrentDocument();
  } else if (selectedNotes.size > 1) {
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        (note as any).__noteData.styles.fontFamily = font;
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    updateStyles();
  } else if (currentNote) {
    currentNote.styles.fontFamily = font;
    applyStylesAndUpdate(currentNote.el, currentNote.styles);
  }
  focusCurrentNoteIfSingle();
};

// Sidebar buttons
$('newNote').onclick = createNewDocument;

$('searchBtn').onclick = () => {
  sidebar.classList.toggle('exp');
  if (sidebar.classList.contains('exp')) searchInput.focus();
};

$('libraryBtn').onclick = () => sidebar.classList.toggle('exp');

$('settingsBtn').onclick = () => showSettingsModal();

$('themeToggle').onclick = () => {
  const isDark = document.body.classList.toggle('dark');
  localStorage.setItem('darkMode', isDark.toString());
  themeText.textContent = isDark ? 'Dark Mode' : 'Light Mode';
};

searchInput.oninput = updateNotesList;

// Global keyboard shortcuts
document.addEventListener('keydown', e => {
  const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
  const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
  
  // Handle Escape key to clear selection
  if (e.key === 'Escape' && selectedNotes.size > 0) {
    e.preventDefault();
    selectedNotes.clear();
    updateSelection();
    return;
  }
  
  // Handle Undo/Redo
  if (ctrlKey && e.key.toLowerCase() === 'z' && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    if (e.shiftKey) {
      redo();
    } else {
      undo();
    }
    return;
  }
  
  // Handle Cmd+N for new document
  if (ctrlKey && e.key.toLowerCase() === 'n' && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    createNewDocument();
    return;
  }
  
  // Handle Cmd+S for save
  if (ctrlKey && e.key.toLowerCase() === 's') {
    e.preventDefault();
    saveCurrentDocument();
    return;
  }
  
  // Handle Cmd+D for duplicate selected notes
  if (ctrlKey && e.key.toLowerCase() === 'd' && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    saveToHistory();
    const offset = 20;
    selectedNotes.forEach(note => {
      const newNote = note.cloneNode(true) as HTMLDivElement;
      const x = parseInt(note.style.left) + offset;
      const y = parseInt(note.style.top) + offset;
      newNote.style.left = x + 'px';
      newNote.style.top = y + 'px';
      
      const noteObj: NoteObject = {
        el: newNote,
        styles: { ...(note as any).__noteData!.styles }
      };
      
      canvas.appendChild(newNote);
      setupNote(newNote, noteObj);
    });
    saveCurrentDocument();
    return;
  }
  
  // Handle font size changes with Cmd+Plus/Minus
  if (ctrlKey && (e.key === '=' || e.key === '+') && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        const currentSize = parseInt((note as any).__noteData.styles.fontSize);
        const newSize = Math.min(currentSize + 2, 72);
        (note as any).__noteData.styles.fontSize = newSize + 'px';
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    updateStyles();
    return;
  }
  
  if (ctrlKey && e.key === '-' && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    selectedNotes.forEach(note => {
      if ((note as any).__noteData) {
        const currentSize = parseInt((note as any).__noteData.styles.fontSize);
        const newSize = Math.max(currentSize - 2, 8);
        (note as any).__noteData.styles.fontSize = newSize + 'px';
        applyStyles(note, (note as any).__noteData.styles);
      }
    });
    updateStyles();
    return;
  }
  
  // Handle arrow keys to move selected notes
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    const moveDistance = e.shiftKey ? 10 : 1;
    let dx = 0, dy = 0;
    
    switch (e.key) {
      case 'ArrowUp': dy = -moveDistance; break;
      case 'ArrowDown': dy = moveDistance; break;
      case 'ArrowLeft': dx = -moveDistance; break;
      case 'ArrowRight': dx = moveDistance; break;
    }
    
    selectedNotes.forEach(note => {
      const x = parseInt(note.style.left) + dx;
      const y = parseInt(note.style.top) + dy;
      note.style.left = Math.max(0, x) + 'px';
      note.style.top = Math.max(0, y) + 'px';
    });
    
    updateSelection();
    saveCurrentDocument();
    return;
  }
  
  // Handle copy selected notes
  if (ctrlKey && e.key.toLowerCase() === 'c' && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    const notesData = Array.from(selectedNotes).map(note => ({
      x: parseInt(note.style.left),
      y: parseInt(note.style.top),
      html: note.innerHTML,
      styles: (note as any).__noteData ? (note as any).__noteData.styles : {} as NoteStyles
    }));
    
    // Store in localStorage since clipboard API requires HTTPS
    localStorage.setItem('anywhereClipboard', JSON.stringify(notesData));
    return;
  }
  
  // Handle paste notes
  if (ctrlKey && e.key.toLowerCase() === 'v' && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    const clipboardData = localStorage.getItem('anywhereClipboard');
    if (clipboardData) {
      try {
        const notesData = JSON.parse(clipboardData);
        saveToHistory();
        
        selectedNotes.clear();
        const offset = 30;
        
        notesData.forEach((noteData: any) => {
          const note = document.createElement('div');
          note.className = 'note';
          note.contentEditable = 'true';
          note.style.left = (noteData.x + offset) + 'px';
          note.style.top = (noteData.y + offset) + 'px';
          note.innerHTML = noteData.html;
          
          const noteObj: NoteObject = {
            el: note,
            styles: { ...noteData.styles }
          };
          
          applyStyles(note, noteData.styles);
          canvas.appendChild(note);
          setupNote(note, noteObj);
          selectedNotes.add(note);
        });
        
        updateSelection();
        saveCurrentDocument();
      } catch (e) {
        console.warn('Failed to paste notes:', e);
      }
    }
    return;
  }
  
  // Handle selected notes deletion
  if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    // Save state before deletion
    saveToHistory();
    selectedNotes.forEach(note => note.remove());
    selectedNotes.clear();
    updateSelection();
    saveCurrentDocument();
    return;
  }
  
  // Handle Ctrl+A to select all notes
  if (ctrlKey && e.key.toLowerCase() === 'a' && !(document.activeElement as HTMLElement).classList.contains('note')) {
    e.preventDefault();
    selectedNotes.clear();
    canvas.querySelectorAll<HTMLDivElement>('.note').forEach(note => selectedNotes.add(note));
    updateSelection();
    return;
  }
  
  // Existing shortcuts for active note
  if (ctrlKey && currentNote && (document.activeElement as HTMLElement).classList.contains('note')) {
    switch (e.key.toLowerCase()) {
      case 'e':
        e.preventDefault();
        ($('alignCenter') as HTMLButtonElement).click();
        break;
      case 'l':
        e.preventDefault();
        ($('alignLeft') as HTMLButtonElement).click();
        break;
      case 'r':
        e.preventDefault();
        ($('alignRight') as HTMLButtonElement).click();
        break;
    }
  }
  
  // Keyboard shortcuts for selected notes (when no note is being edited)
  if (ctrlKey && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    switch (e.key.toLowerCase()) {
      case 'b':
        e.preventDefault();
        ($('bold') as HTMLButtonElement).click();
        break;
      case 'i':
        e.preventDefault();
        ($('italic') as HTMLButtonElement).click();
        break;
      case 'u':
        e.preventDefault();
        ($('underline') as HTMLButtonElement).click();
        break;
      case 'e':
        e.preventDefault();
        ($('alignCenter') as HTMLButtonElement).click();
        break;
      case 'l':
        e.preventDefault();
        ($('alignLeft') as HTMLButtonElement).click();    
        break;
      case 'r':
        e.preventDefault();
        ($('alignRight') as HTMLButtonElement).click();
        break;
    }
  }
  
  // List keyboard shortcuts
  if (ctrlKey && e.shiftKey && selectedNotes.size > 0 && !(document.activeElement as HTMLElement).classList.contains('note')) {
    switch (e.key) {
      case '*':
      case '8':
        e.preventDefault();
        ($('bulletList') as HTMLButtonElement).click();
        break;
      case '&':
      case '7':
        e.preventDefault();
        ($('numberedList') as HTMLButtonElement).click();
        break;
    }
  }
});

// Initialize
loadTheme();
loadSettings();
loadDocuments();
initHeaderAutoHide();
</file>

<file path=".gitignore">
node_modules/
dist/
*.log
.DS_Store
</file>

<file path="package.json">
{
  "name": "anywhere",
  "version": "1.0.0",
  "description": "A freeform note-taking application with TypeScript",
  "main": "src/app.js",
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch",
    "serve": "python -m http.server 8080",
    "dev-server": "live-server src --port=3000 --wait=500",
    "dev": "concurrently \"npm run watch\" \"live-server --port=3000 --wait=500 --open=src/index.html\""
  },
  "keywords": [
    "notes",
    "typescript",
    "canvas",
    "note-taking"
  ],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "concurrently": "^9.2.0",
    "live-server": "^1.2.2",
    "typescript": "^5.3.0"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "none",
    "lib": ["DOM", "DOM.Iterable", "ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": false,
    "outDir": "./dist",
    "rootDir": "./src",
    "sourceMap": true,
    "removeComments": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": false,
    "exactOptionalPropertyTypes": false
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**Anywhere** is a freeform note-taking application built with TypeScript, HTML, and CSS. It provides an infinite canvas where users can click anywhere to create text notes with rich formatting options.

## Architecture

### Core Components

- **Canvas System**: The main infinite workspace where notes are positioned absolutely
- **Note Management**: Each note is a contentEditable div with persistent styling and positioning
- **Document System**: Multiple documents/pages with save/load functionality via localStorage
- **State Management**: Global state variables track current note, document, and UI state

### Key Modules

- **Document Management** (`loadDocuments`, `saveDocuments`, `createNewDocument`): Handles multiple note documents with localStorage persistence
- **Note Operations** (`setupNote`, `applyStyles`, `updateStyles`): Individual note creation, editing, and formatting
- **Selection System** (`updateSelection`, selection box): Multi-note selection with group operations
- **Toolbar System**: Floating formatting toolbar with drag functionality
- **Sidebar System**: Collapsible sidebar with document browser, search, and theme toggle

### Data Structure

```typescript
interface Document {
  id: string;
  title: string;
  notes: NoteData[];
  pinned: boolean;
  hasCustomTitle?: boolean;
}

interface NoteData {
  x: number;
  y: number;
  text: string;
  html: string;
  styles: NoteStyles;
}

interface NoteStyles {
  bold: boolean;
  italic: boolean;
  underline: boolean;
  strike: boolean;
  fontSize: string;
  fontFamily: string;
  align: 'left' | 'center' | 'right';
  listType: 'none' | 'bullet' | 'numbered';
}
```

## Development Commands

The project now uses TypeScript for enhanced type safety and developer experience:

- **Build**: `npm run build` - Compiles TypeScript to JavaScript in `/dist` folder
- **Watch Mode**: `npm run watch` - Automatically recompile TypeScript on changes
- **Development**: Open `src/index.html` in a browser (references compiled JS from `/dist`)
- **Local Server**: `npm run serve` - Serves application on localhost:8080
- **Testing**: Manual testing in browser - no automated test suite yet

## Key Features

- **Infinite Canvas**: Click anywhere to create a note
- **Rich Text Formatting**: Bold, italic, underline, strikethrough, font size/family, alignment
- **Multi-selection**: Shift+click or drag selection box for group operations
- **Document Management**: Multiple documents with search, pinning, and organization
- **Persistence**: All data saved to localStorage automatically
- **Theme System**: Light/dark mode toggle
- **Responsive Sidebar**: Collapsible document browser
- **Keyboard Shortcuts**: Standard text formatting shortcuts (Ctrl/Cmd+B, I, U, etc.)

## File Structure

```
src/
├── index.html     # Main application structure and UI
├── app.ts         # Core application logic and interactions (TypeScript)
├── types.ts       # TypeScript type definitions
└── styles.css     # Complete styling including dark theme
dist/
├── app.js         # Compiled JavaScript (generated)
├── app.js.map     # Source map for debugging
├── types.js       # Compiled type definitions
└── types.js.map   # Source map for types
```

## State Management Patterns

- **Global Variables**: All state managed through typed global variables at top of app.ts
- **Event-Driven**: Heavy use of DOM event listeners for interactions
- **Auto-Save**: Document changes trigger automatic localStorage updates
- **Theme Persistence**: Theme preference saved to localStorage
- **Type Safety**: All data structures and functions are fully typed for better reliability

## UI Interaction Patterns

- **Canvas Click**: Creates new note at click position
- **Note Focus**: Shows formatting toolbar
- **Toolbar Dragging**: Toolbar can be repositioned by dragging
- **Selection Box**: Drag on empty canvas to select multiple notes
- **Group Operations**: Selected notes can be moved and formatted together
</file>

<file path="readme.md">
# Anywhere - Freeform Note Taking

A freeform note-taking application that provides an infinite canvas where you can click anywhere to create text notes with rich formatting options.

## Features

- **Infinite Canvas**: Click anywhere to create a note
- **Rich Text Formatting**: Bold, italic, underline, strikethrough, font size/family, alignment
- **Multi-selection**: Select multiple notes for group operations
- **Document Management**: Multiple documents with search, pinning, and organization
- **Undo/Redo Support**: Full undo/redo history for all operations
- **Copy/Paste**: Copy and paste notes within and between documents
- **Theme System**: Light/dark mode toggle
- **Auto-save**: All changes saved automatically to localStorage

## Keyboard Shortcuts

### Selection & Navigation
- **Escape** - Clear current selection
- **Ctrl/Cmd + A** - Select all notes
- **Delete/Backspace** - Delete selected notes
- **Arrow Keys** - Move selected notes (1px increments)
- **Shift + Arrow Keys** - Move selected notes (10px increments)

### Document Management
- **Ctrl/Cmd + N** - Create new document
- **Ctrl/Cmd + S** - Force save current document

### Editing & Formatting
- **Ctrl/Cmd + Z** - Undo last action
- **Ctrl/Cmd + Shift + Z** - Redo last action
- **Ctrl/Cmd + C** - Copy selected notes
- **Ctrl/Cmd + V** - Paste copied notes
- **Ctrl/Cmd + D** - Duplicate selected notes

#### Text Formatting (selected notes or active note)
- **Ctrl/Cmd + B** - Toggle bold
- **Ctrl/Cmd + I** - Toggle italic  
- **Ctrl/Cmd + U** - Toggle underline
- **Ctrl/Cmd + E** - Center align text
- **Ctrl/Cmd + L** - Left align text
- **Ctrl/Cmd + R** - Right align text

#### Font Size (selected notes only)
- **Ctrl/Cmd + Plus/=** - Increase font size
- **Ctrl/Cmd + Minus** - Decrease font size

## Usage

1. **Creating Notes**: Click anywhere on the canvas to create a new note
2. **Selecting Notes**: 
   - Click and drag to select multiple notes with selection box
   - Shift+click to add notes to selection
   - Click on individual notes to select them
3. **Formatting**: Use the toolbar or keyboard shortcuts to format text
4. **Moving Notes**: Drag individual notes or use arrow keys for precise positioning
5. **Documents**: Use the sidebar to manage multiple documents, search, and organize

## Development

This is a pure client-side application built with vanilla HTML, CSS, and JavaScript.

**Development**: Open `src/index.html` directly in a browser or use a local server  
**No Build Process**: No dependencies or build tools required
</file>

<file path="src/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Anywhere</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="sidebar">
  <div class="sidebar-logo">
    <span class="logo-full">Anywhere</span>
    <span class="logo-short">A</span>
  </div>
  <button class="sb-btn" id="libraryBtn">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <rect x="3" y="3" width="18" height="18" rx="2"></rect>
      <line x1="9" y1="3" x2="9" y2="21"></line>
    </svg>
    <span>Toggle Sidebar</span>
  </button>
  <button class="sb-btn" id="newNote">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="12" y1="5" x2="12" y2="19"></line>
      <line x1="5" y1="12" x2="19" y2="12"></line>
    </svg>
    <span>New Note</span>
  </button>
  <button class="sb-btn" id="searchBtn">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="11" cy="11" r="8"></circle>
      <path d="m21 21-4.35-4.35"></path>
    </svg>
    <span>Search Notes</span>
  </button>
  <input type="text" id="searchInput" placeholder="Search notes...">
  <div id="notesList"></div>
  <div class="sb-footer">
    <button class="sb-btn" id="settingsBtn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
      <span>Settings</span>
    </button>
    <button class="sb-btn" id="themeToggle">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
      </svg>
      <span id="themeText">Light Mode</span>
    </button>
  </div>
</div>

<div id="canvas">
  <div id="logo">Anywhere<div id="logo-subtext">Your ideas anywhere, anyplace</div></div>
</div>

<div id="toolbar">
  <button id="bold"><b>B</b></button>
  <button id="italic"><i>I</i></button>
  <button id="underline"><u>U</u></button>
  <button id="strike"><s>S</s></button>
  <div class="sep"></div>
  <button id="alignLeft" title="Align Left">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="3" y1="6" x2="21" y2="6"/>
      <line x1="3" y1="12" x2="15" y2="12"/>
      <line x1="3" y1="18" x2="18" y2="18"/>
    </svg>
  </button>
  <button id="alignCenter" title="Align Center">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="3" y1="6" x2="21" y2="6"/>
      <line x1="6" y1="12" x2="18" y2="12"/>
      <line x1="4" y1="18" x2="20" y2="18"/>
    </svg>
  </button>
  <button id="alignRight" title="Align Right">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="3" y1="6" x2="21" y2="6"/>
      <line x1="9" y1="12" x2="21" y2="12"/>
      <line x1="6" y1="18" x2="21" y2="18"/>
    </svg>
  </button>
  <div class="sep"></div>
  <button id="bulletList" title="Bullet List">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="3" cy="6" r="1"/>
      <line x1="7" y1="6" x2="21" y2="6"/>
      <circle cx="3" cy="12" r="1"/>
      <line x1="7" y1="12" x2="21" y2="12"/>
      <circle cx="3" cy="18" r="1"/>
      <line x1="7" y1="18" x2="21" y2="18"/>
    </svg>
  </button>
  <button id="numberedList" title="Numbered List">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="10" y1="6" x2="21" y2="6"/>
      <line x1="10" y1="12" x2="21" y2="12"/>
      <line x1="10" y1="18" x2="21" y2="18"/>
      <path d="M4 6h1v4"/>
      <path d="M4 10h2"/>
      <path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"/>
    </svg>
  </button>
  <div class="sep"></div>
  <select id="fontSize">
    <option value="12px">12</option>
    <option value="14px">14</option>
    <option value="16px" selected>16</option>
    <option value="18px">18</option>
    <option value="20px">20</option>
    <option value="24px">24</option>
    <option value="28px">28</option>
    <option value="32px">32</option>
    <option value="48px">48</option>
  </select>
  <select id="fontFamily">
    <option value="-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif">Sans</option>
    <option value="Georgia,'Times New Roman',serif">Serif</option>
    <option value="'Courier New',Consolas,monospace">Mono</option>
    <option value="Arial,Helvetica,sans-serif">Arial</option>
    <option value="'Times New Roman',Times,serif">Times</option>
    <option value="Verdana,Geneva,sans-serif">Verdana</option>
  </select>
</div>

<script src="../dist/app.js"></script>
</body>
</html>
</file>

<file path="src/styles.css">
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  :root {
    --bg: #fafafa;
    --txt: #333;
    --sb: #344532;
    --st: #ccc;
    --sh: rgba(255, 255, 255, 0.1);
    --nf: rgba(255, 255, 255, 0.5);
    --nb: rgba(0, 0, 0, 0.1);
    --tb: rgba(52, 69, 50, 0.9);
    --ts: rgba(0, 0, 0, 0.1);
    --th: rgba(0, 0, 0, 0.05);
    --ta: rgba(0, 0, 0, 0.1);
    --ib: #1a1a1a;
    --bd: #444;
    --lc: #ccc;
  }
  
  body.dark {
    --bg: #1a1a1a;
    --txt: #e0e0e0;
    --sb: #2d3c2a;
    --nf: rgba(255, 255, 255, 0.1);
    --nb: rgba(255, 255, 255, 0.2);
    --tb: rgba(45, 60, 42, 0.9);
    --ts: rgba(0, 0, 0, 0.3);
    --th: rgba(255, 255, 255, 0.1);
    --ta: rgba(255, 255, 255, 0.2);
    --ib: #000;
    --bd: #555;
    --lc: #666;
  }
  
  body {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--txt);
    transition: background 0.3s, color 0.3s;
  }
  
  /* Logo */
  #logo {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 60px;
    font-weight: 300;
    color: var(--lc);
    pointer-events: none;
    font-family: Georgia, serif;
    letter-spacing: 0.05em;
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
    text-align: center;
  }

  #logo-subtext {
    font-size: 20px;
    font-weight: 300;
    color: var(--lc);
    font-family: Georgia, serif;
    letter-spacing: 0.05em;
    margin-top: 12px;
    opacity: 0.8;
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
  }
  
  #logo.slide-away {
    top: -60px;
    left: -200px;
    transform: none;
    font-size: 30px;
    opacity: 0;
  }

  #logo.slide-away #logo-subtext {
    opacity: 0;
  }
  
  #logo.hidden {
    display: none;
  }
  
  /* Sidebar Logo */
  .sidebar-logo {
    padding: 14px;
    font-size: 18px;
    font-weight: 300;
    color: #fff;
    font-family: Georgia, serif;
    letter-spacing: 0.05em;
    text-align: center;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .logo-full {
    display: none;
  }
  
  .logo-short {
    display: block;
  }
  
  #sidebar.exp .logo-full {
    display: block;
  }
  
  #sidebar.exp .logo-short {
    display: none;
  }
  
  
  /* Notes */
  .note {
    position: absolute;
    outline: none;
    border: none;
    background: transparent;
    min-width: 20px;
    min-height: 20px;
    padding: 2px;
    cursor: text;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: var(--txt);
  }
  
  .note:focus {
  }
  
  .note.selected {
    background: rgba(52, 69, 50, 0.1);
    box-shadow: 0 0 0 2px rgba(52, 69, 50, 0.5);
  }

  /* List styling */
  .note ul {
    margin: 0;
    padding-left: 20px;
    list-style-type: disc;
  }

  .note ol {
    margin: 0;
    padding-left: 20px;
    list-style-type: decimal;
  }

  .note li {
    margin: 2px 0;
  }
  
  /* Toolbar */
  #toolbar {
    position: fixed;
    top: -60px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--tb);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 8px;
    box-shadow: 0 2px 20px var(--ts);
    padding: 8px 12px;
    display: flex;
    gap: 8px;
    align-items: center;
    transition: top 0.3s ease;
    z-index: 1000;
  }
  
  #toolbar.show {
    top: 20px;
  }

  /* Toolbar hover zone - invisible area at top to reveal toolbar */
  #toolbarHoverZone {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 80px;
    z-index: 999;
    pointer-events: auto;
    background: transparent;
  }
  
  #toolbar button {
    background: none;
    border: none;
    padding: 6px 10px;
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    transition: background 0.2s;
    color: #ffffff;
  }
  
  #toolbar button:hover {
    background: var(--th);
  }
  
  #toolbar button.active {
    background: var(--ta);
  }
  
  #toolbar select {
    padding: 4px 8px;
    border: 1px solid var(--bd);
    border-radius: 4px;
    background: rgba(52, 69, 50, 0.95);
    color: #ffffff;
    cursor: pointer;
    font-size: 14px;
    outline: none;
  }
  
  .sep {
    width: 1px;
    height: 20px;
    background: var(--bd);
  }
  
  /* Sidebar */
  #sidebar {
    position: fixed;
    left: 0;
    top: 0;
    height: 100vh;
    width: 48px;
    background: var(--sb);
    transition: width 0.3s ease;
    z-index: 1001;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  
  
  #sidebar.exp {
    width: 260px;
  }
  
  .sb-btn {
    width: 100%;
    height: 48px;
    background: none;
    border: none;
    color: var(--st);
    cursor: pointer;
    display: flex;
    align-items: center;
    padding: 0 14px;
    transition: background 0.2s;
    flex-shrink: 0;
    overflow: hidden;
  }
  
  
  .sb-btn:hover {
    background: var(--sh);
  }
  
  .sb-btn svg {
    width: 20px;
    height: 20px;
    flex-shrink: 0;
  }
  
  .sb-btn span {
    margin-left: 20px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.3s;
  }
  
  #sidebar.exp .sb-btn span {
    opacity: 1;
  }
  
  #searchInput {
    width: calc(100% - 28px);
    margin: 10px 14px;
    padding: 12px;
    border: none;
    background: transparent;
    color: var(--st);
    border-radius: 0;
    border-bottom: 1px solid var(--sh);
    display: none;
    font-size: 14px;
    outline: none;
  }
  
  #searchInput::placeholder {
    color: rgba(204, 204, 204, 0.6);
  }
  
  #sidebar.exp #searchInput {
    display: block;
  }
  
  #notesList {
    flex: 1;
    
    display: none;
    padding: 10px;
  }
  
  #sidebar.exp #notesList {
    display: block;
  }
  
  .note-item {
    padding: 10px;
    margin-bottom: 5px;
    background: var(--sh);
    border-radius: 4px;
    cursor: pointer;
    color: var(--st);
    transition: background 0.2s;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  
  .note-item:hover {
    background: rgba(255, 255, 255, 0.15);
  }
  
  .note-item:hover .note-actions {
    opacity: 1;
  }
  
  .note-item.active {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
  }
  
  .note-text {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .note-text input {
    background: transparent;
    border: 1px solid var(--bd);
    padding: 2px 6px;
    color: inherit;
    font: inherit;
    width: 100%;
    border-radius: 3px;
  }
  
  .note-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
  }
  
  .note-actions button {
    background: none;
    border: none;
    padding: 4px;
    cursor: pointer;
    color: var(--st);
    border-radius: 3px;
    transition: background 0.2s;
  }
  
  .note-actions button:hover {
    background: var(--sh);
  }
  
  .note-actions svg {
    width: 16px;
    height: 16px;
  }
  
  .pinned-section {
    border-bottom: 1px solid var(--sh);
    margin-bottom: 10px;
    padding-bottom: 10px;
  }
  
  .pinned-title {
    font-size: 12px;
    text-transform: uppercase;
    color: var(--st);
    margin-bottom: 8px;
    opacity: 0.7;
  }
  
  /* Canvas */
  #canvas {
    position: absolute;
    top: 0;
    left: 48px;
    right: 0;
    bottom: 0;
    cursor: crosshair;
    transition: left 0.3s ease;
  }
  
  #sidebar.exp ~ #canvas {
    left: 260px;
  }
  
  .sb-footer {
    margin-top: auto;
    border-top: 1px solid var(--sh);
  }
  
  /* Selection */
  .select-box {
    position: absolute;
    border: 1px dashed rgba(52, 69, 50, 0.7);
    background: rgba(52, 69, 50, 0.1);
    pointer-events: none;
  }
  
  .selection-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    background: #344532;
    border: 2px solid #fff;
    border-radius: 2px;
    cursor: move;
    z-index: 100;
  }
  
  /* Modal */
  .modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
  }
  
  .modal-content {
    background: var(--sb);
    border-radius: 8px;
    padding: 24px;
    max-width: 400px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }
  
  .modal-content h3 {
    color: #fff;
    margin-bottom: 16px;
    text-align: left;
  }
  
  .modal-content p {
    color: var(--st);
    margin-bottom: 20px;
    text-align: left;
  }
  
  .modal-buttons {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
  }
  
  .modal-buttons button {
    padding: 8px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
  }
  
  .modal-buttons .cancel {
    background: #ffffff;
    border: 1px solid #cccccc;
    color: #333333;
  }
  
  .modal-buttons .confirm {
    background: #2a3628;
    color: #fff;
  }
  
  .modal-buttons button:hover {
    transform: translateY(-1px);
  }

  /* Settings Modal */
  .settings-modal {
    width: 680px;
    height: 600px;
    min-width: 680px;
    max-width: 680px;
    min-height: 600px;
    max-height: 600px;
    padding: 0;
    background: #344532;
    position: relative;
    overflow: hidden;
    box-sizing: border-box;
  }
  
  .tabbed-modal {
    display: flex;
    flex-direction: row;
    height: 600px;
    min-height: 600px;
    max-height: 600px;
  }
  
  .settings-modal .settings-header {
    padding: 32px 0 24px 0;
    margin-bottom: 0;
    text-align: left !important;
    display: block;
    width: 100%;
  }
  
  .settings-modal .settings-header h3 {
    margin: 0 0 8px 0;
    color: #fff;
    font-size: 18px;
    font-weight: 500;
    text-align: left !important;
    display: block;
    width: 100%;
  }
  
  .settings-modal .settings-header .tab-description {
    margin: 0 0 24px 0;
    color: var(--st);
    font-size: 14px;
    font-weight: 400;
    padding-bottom: 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    text-align: left !important;
    display: block;
    width: 100%;
  }
  
  /* Additional specific selectors for the settings panels */
  .settings-modal .settings-panel h3 {
    text-align: left !important;
  }
  
  .settings-modal .settings-panel p {
    text-align: left !important;
  }
  
  .settings-modal .settings-panel .tab-description {
    text-align: left !important;
  }
  
  .modal-close {
    position: absolute;
    top: 18px;
    left: 18px;
    background: none;
    border: none;
    color: var(--st);
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background 0.2s;
    z-index: 10;
  }
  
  .modal-close:hover {
    background: var(--bd);
  }
  
  .settings-body {
    display: flex;
    height: 600px;
    min-height: 600px;
    max-height: 600px;
  }
  
  .settings-sidebar {
    width: 60px;
    background: var(--sh);
    padding: 60px 0 0 0;
    display: flex;
    flex-direction: column;
    position: relative;
    flex-shrink: 0;
    height: 600px;
  }
  
  .settings-tab {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 18px 0;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    margin-bottom: 4px;
  }
  
  .settings-tab:hover {
    background: rgba(255, 255, 255, 0.1);
  }
  
  .settings-tab.active {
    background: #344532;
    color: #fff;
  }
  
  .settings-tab svg {
    width: 24px;
    height: 24px;
    stroke: currentColor;
  }
  
  .settings-tab span {
    display: none;
  }
  
  .settings-content {
    flex: 1 1 auto;
    overflow-y: auto;
    min-height: 0;
    width: 620px;
  }
  
  /* Custom Scrollbar for Settings Content */
  .settings-content::-webkit-scrollbar {
    width: 8px;
  }
  
  .settings-content::-webkit-scrollbar-track {
    background: transparent;
  }
  
  .settings-content::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
  }
  
  .settings-content::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }
  
  .settings-panel {
    display: none;
    padding: 0 32px 32px 32px;
  }
  
  .settings-panel.active {
    display: block;
  }
  
  /* Platform Toggle */
  .platform-toggle {
    margin-bottom: 24px;
  }
  
  .toggle-label {
    color: #fff;
    font-weight: 500;
    margin-bottom: 12px;
    display: block;
  }
  
  .toggle-switch {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .toggle-switch input[type="radio"] {
    display: none;
  }
  
  .toggle-switch label {
    padding: 8px 16px;
    background: var(--bd);
    color: var(--st);
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
    border: 1px solid var(--bd);
  }
  
  .toggle-switch label:hover {
    background: var(--sh);
  }
  
  .toggle-switch input[type="radio"]:checked + label {
    background: #344532;
    color: #fff;
    border-color: #344532;
  }
  
  /* Shortcuts Layout */
  .shortcuts-content {
    /* No custom height or overflow - let parent handle scrolling */
  }
  
  .shortcuts-section {
    margin-bottom: 32px;
  }
  
  .shortcuts-section:last-child {
    margin-bottom: 0;
  }
  
  .shortcuts-section h4 {
    color: #fff;
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 16px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  .shortcuts-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .shortcut-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
  }
  
  .shortcut-action {
    color: var(--st);
    font-size: 14px;
  }
  
  .shortcut-key {
    color: #fff;
    font-size: 12px;
    font-family: 'Courier New', monospace;
    background: var(--sh);
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    font-weight: 500;
  }
  

  .setting-group {
    margin-bottom: 24px;
  }

  .setting-group:last-child {
    margin-bottom: 0;
  }

  .setting-group label {
    display: block;
    color: #fff;
    margin-bottom: 12px;
    font-weight: 500;
    font-size: 14px;
  }

  .setting-group input[type="range"] {
    width: 100%;
    height: 6px;
    background: var(--bd);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
    appearance: none;
  }

  .setting-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: #344532;
    border-radius: 50%;
    cursor: pointer;
  }

  .setting-group input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: #344532;
    border-radius: 50%;
    cursor: pointer;
    border: none;
  }

  .setting-group input[type="checkbox"] {
    margin-right: 8px;
    transform: scale(1.2);
  }

  .setting-group input[type="number"] {
    width: 80px;
    padding: 10px 12px;
    border: 1px solid var(--bd);
    border-radius: 6px;
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    font-size: 14px;
    outline: none;
    -moz-appearance: textfield;
    transition: border-color 0.2s, background-color 0.2s;
  }
  
  .setting-group input[type="number"]:focus {
    border-color: #344532;
    background: rgba(255, 255, 255, 0.15);
  }

  .setting-group input[type="number"]::-webkit-outer-spin-button,
  .setting-group input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .delete-all-btn {
    width: 100%;
    padding: 12px;
    background: #2a3628;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.2s;
  }

  .delete-all-btn:hover {
    background: #1f2a1d;
  }

  .modal-buttons .delete-confirm {
    background: #dc2626;
  }

  .modal-buttons .delete-confirm:hover {
    background: #b91c1c;
  }
</file>

</files>
